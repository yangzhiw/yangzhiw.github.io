<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>橘子不酸的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录生活点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="橘子不酸的博客">
<meta property="og:url" content="https://yangzhiw.github.io/page/6/index.html">
<meta property="og:site_name" content="橘子不酸的博客">
<meta property="og:description" content="记录生活点滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="橘子不酸的博客">
<meta name="twitter:description" content="记录生活点滴">
  
    <link rel="alternate" href="/atom.xml" title="橘子不酸的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">橘子不酸的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yangzhiw.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java-基础题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/01/java-基础题/" class="article-date">
  <time datetime="2016-08-01T01:54:12.000Z" itemprop="datePublished">2016-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/01/java-基础题/">java 复习资料</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p>1，面向对象和面向过程的区别<br>2，java的三大特性</p>
<hr>
<pre><code>封装，继承，多态
</code></pre><p>3，OverLoad与Override的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   Override（重写，覆盖） </div><div class="line">方法名、参数、返回值相同。</div><div class="line">子类方法不能缩小父类方法的访问权限。</div><div class="line">子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</div><div class="line">存在于父类和子类之间。</div><div class="line">方法被定义为final不能被重写。</div><div class="line"></div><div class="line">   Overload（重载，过载）</div><div class="line">参数类型、个数、顺序至少有一个不相同。  </div><div class="line">不能重载只有返回值不同的方法名。</div><div class="line">存在于父类和子类、同类中。</div></pre></td></tr></table></figure></p>
<p>4，构造器不能被修饰Override<br>5，访问控制符public,protected,private,以及默认的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">作用域      当前类      同包   子类    其他</div><div class="line">public        √        √       √      √</div><div class="line">protected     √        √       √      ×</div><div class="line">default       √        √       ×      ×</div><div class="line">private       √        ×       ×      ×</div></pre></td></tr></table></figure></p>
<p>6，String和StringBuffer、StringBuilder的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">可变与不可变</div><div class="line">String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。</div><div class="line">private final char value[];</div><div class="line"></div><div class="line">StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符</div><div class="line">数组保存字符串，如下就是，可知这两种对象都是可变的。</div><div class="line"></div><div class="line">char[] value;</div><div class="line">线程是否安全</div><div class="line">StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</div><div class="line">StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</div></pre></td></tr></table></figure></p>
<p>7，抽象类和接口的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</div><div class="line"></div><div class="line">　　<span class="number">2</span>）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</div><div class="line"></div><div class="line">　　<span class="number">3</span>）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</div><div class="line"></div><div class="line">　　<span class="number">4</span>）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</div></pre></td></tr></table></figure></p>
<p>8，自动装箱与拆箱<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">基本数据类型的自动装箱(autoboxing)、拆箱(unboxing)是自J2SE <span class="number">5.0</span>开始提供的功能。 </div><div class="line">基本数据与对象的区别</div><div class="line">如：int t = <span class="number">1</span>；     t.  后面是没有方法滴。</div><div class="line"></div><div class="line">    Integer t =<span class="number">1</span>； t.  后面就有很多方法可让你调用了。</div><div class="line"></div><div class="line">Integer i = <span class="number">100</span>; // 自动装箱</div><div class="line">相当于编译器自动为您作以下的语法编译：Integer i = Integer.valueOf(<span class="number">100</span>);</div><div class="line">Integer i = <span class="number">10</span>; //装箱 </div><div class="line">int t = i; //拆箱，实际上执行了 int t = i.intValue();    </div><div class="line"></div><div class="line">注意：integer值得默认大小是<span class="bullet">-127</span><span class="bullet">-128</span></div></pre></td></tr></table></figure></p>
<p>7，泛型<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">泛型是Java SE <span class="number">1.5</span>的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数,</div><div class="line">类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，</div><div class="line">将泛型java代码直接转换成普通java字节码。</div><div class="line">     类型擦除的主要过程如下：</div><div class="line">     <span class="number">1.</span>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</div><div class="line">     <span class="number">2.</span>移除所有的类型参数。</div></pre></td></tr></table></figure></p>
<p>8,Java中的集合类及其关系图<br>关系图<br><img src="/2016/08/01/java-基础题/java_collection.jpg" alt="微服务架构图" title="微服务架构图"><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　上述类图中，实线边框的是实现类，比如ArrayList，LinkedList，HashMap等，</div><div class="line">  折线边框的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，</div><div class="line">  而点线边框的是接口，比如Collection，Iterator，List等。</div><div class="line">  	　		是否有序	是否允许元素重复</div><div class="line">Collection		否		是</div><div class="line">List			是		是</div><div class="line">Set	AbstractSet	否		否</div><div class="line">　	HashSet    	 否		否</div><div class="line">　	TreeSet		是		否</div><div class="line">Map	AbstractMap	否	使用key-value来映射和存储数据，key必须唯一，value可以重复</div><div class="line">　	HashMap</div><div class="line">　	TreeMap		是（用二叉排序树）</div></pre></td></tr></table></figure></p>
<p>9，HashMap的实现原理<br>   见此链接<br>10，HashTable实现原理<br>   见此链接<br>11，HashMap与HashTable的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">第一，继承不同。</div><div class="line"></div><div class="line">public class Hashtable extends Dictionary implements Map</div><div class="line">public class HashMap  extends AbstractMap implements Map</div><div class="line">第二</div><div class="line"></div><div class="line">Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，</div><div class="line">可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</div><div class="line">如果为了要线程安全，可以使用CurrentHashMap</div><div class="line"></div><div class="line">第三</div><div class="line"></div><div class="line">Hashtable中，key和value都不允许出现<span class="literal">null</span>值。</div><div class="line"></div><div class="line">在HashMap中，<span class="literal">null</span>可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为<span class="literal">null</span>。当get()方法返回<span class="literal">null</span>值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为<span class="literal">null</span>。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</div><div class="line"></div><div class="line">第四，两个遍历方式的内部实现上不同。</div><div class="line"></div><div class="line">Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</div><div class="line"></div><div class="line">第五</div><div class="line"></div><div class="line">哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</div><div class="line"></div><div class="line">第六</div><div class="line"></div><div class="line">Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是<span class="number">11</span>，增加的方式是 old*<span class="number">2</span>+<span class="number">1</span>。HashMap中hash数组的默认大小是<span class="number">16</span>，而且一定是<span class="number">2</span>的指数。</div></pre></td></tr></table></figure></p>
<p>12，ArrayList和vector区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）  Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。 </div><div class="line"><span class="number">2</span>） 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加<span class="number">50</span>%的大小，这样,ArrayList就有利于节约内存空间。</div></pre></td></tr></table></figure></p>
<p>13,ArrayList和LinkedList区别及使用场景<br>区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ArryList初始化时，elementData数组大小默认为<span class="number">10</span>；</div><div class="line">每次add（）时，先调用ensureCapacity（）保证数组不会溢出，如果此时已满，会扩展为数组length的<span class="number">1.5</span>倍+<span class="number">1</span>，</div><div class="line">然后用array.copy的方法，将原数组拷贝到新的数组中；线程不安全。</div><div class="line"></div><div class="line">LinkedList是基于双链表实现的：</div><div class="line">使用header的优点是：在任何一个条目（包括第一个和最后一个）都有一个前置条目和一个后置条目，</div><div class="line">因此在LinkedList对象的开始或者末尾进行插入操作没有特殊的地方；</div></pre></td></tr></table></figure></p>
<p>使用场景<br>   （1）查询操作多，ArrayList对象要远优于LinkedList对象；</p>
<p>   （2）修改和删除操作多，LinkedList对象要远优于ArrayList对象；</p>
<p>14，static和final区别和用途<br> static<br> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">修饰变量：静态变量随着类被加载时被完全初始化，在内存中只有一个，并且JVM只会为它分配一次内存，所有类共享此变量。</div><div class="line">修饰方法：在类加载时存在，不依赖任何实例，方法必须实现，不能用abstract修饰。</div><div class="line">修饰代码块：在类加载完之后执行代码块的内容。</div><div class="line">   父类静态代码块-&gt;子类静态代码块-&gt;父类非静态代码块-&gt;父类构造方法—&gt;子类非静态代码块-&gt;子类构造方法</div></pre></td></tr></table></figure></p>
<p> final<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> 修饰变量：</div><div class="line">  编译器常量：类加载是完成初始化，编译后带入到任何计算中，只能基本数据类型。</div><div class="line">  运行时常量：基本数据类型或引用数据类型，引用不可变，但引用的类型可变。</div><div class="line">修饰方法：方法不能被继承，不能被子类修改。</div><div class="line">修饰类：不能被继承。</div><div class="line">修饰形参：final形参不可变。</div></pre></td></tr></table></figure></p>
<p>15,HashMap和ConcurrentHashMap的区别<br>HashMap不是线程安全的，ConcurrentHashMap是线程安全的。<br>ConcurrentHashMap将整个Hash桶进行了分段segment，每个segment上面都有锁的存在。<br>ConcurrentHashMap的锁的粒度越细，并发性能越好。</p>
<p>16，线程安全<br>定义：类的行为与其的规范一致。<br>如何保证线程安全：<br>   对变量使用validate<br>   对程序进行加锁<br>17，多线程如何进行信息交互<br>Object中的方法，wait，notify(),notifyAll()</p>
<p>18,多线程共用一个变量需要注意什么<br>在线程对象runnable中定义了全局变量，run方法会修改该变量时，如果有多个线程同时使用该变量时候，可能有错误发生。<br>ThreadLocal是JDK引入的一种机制，它用于解决线程的共享变量，使用ThreadLocal声明的变量，即使在线程中属于全局变量，<br>针对每个线程来讲，这个变量是独立的。<br>validate变量每次被线程访问时，都会使得线程从主内存中重读该变量的最新值，而该变量发生修改时，也是把修改的值写入到<br>内存中去。</p>
<p>19，线程池<br>基本组成部分：<br>  线程管理器(ThreadPool) :用户创建并管理线程池，包括创建，摧毁线程池，添加新任务。<br>  工作线程（poolwork）:线程池中的线程，在没有任务时，处于等待状态，可以循环使用。<br>  任务接口（Task）：每个任务必须实现的接口，以供工作线程调度的执行，它主要规定了任务的入口，<br>    任务完成的收尾工作，任务的执行状态等。<br>  任务队列（Taskqueue）：用于存放没有处理的任务，提供一种缓存机制。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/08/01/java-基础题/" data-id="ciy19444y000yzg9opnzees5b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础/">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring-AOP-注解开发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/28/spring-AOP-注解开发/" class="article-date">
  <time datetime="2016-07-28T07:54:39.000Z" itemprop="datePublished">2016-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/28/spring-AOP-注解开发/">spring AOP 注解开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>AOP主要包含了通知、切点和连接点等术语，介绍如下:</p>
<h2 id="通知（advice）"><a href="#通知（advice）" class="headerlink" title="通知（advice）"></a>通知（advice）</h2><p>通知定义了切面是什么以及何时调用，何时调用包含以下几种<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Before 在方法被调用之前调用通知</div><div class="line">After 在方法完成之后调用通知，无论方法执行是否成功</div><div class="line">After-returning 在方法成功执行之后调用通知</div><div class="line">After-throwing 在方法抛出异常后调用通知</div><div class="line">Around 通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</div></pre></td></tr></table></figure></p>
<h2 id="切点-PointCut"><a href="#切点-PointCut" class="headerlink" title="切点(PointCut)"></a>切点(PointCut)</h2><p>通知定义了切面的什么和何时，切点定义了何处，切点的定义会匹配通知所要织入的一个或多个连接点，<br>我们通常使用明确的类的方法名称来指定这些切点，或是利用正则表达式定义匹配的类和方法名称来指定这些切点。</p>
<h2 id="连接点-JoinPoint"><a href="#连接点-JoinPoint" class="headerlink" title="连接点(JoinPoint)"></a>连接点(JoinPoint)</h2><p>连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时，抛出异常时，甚至是修改一个字段时，<br>切面代码可以利用这些连接点插入到应用的正常流程中，并添加新的行为，如日志、安全、事务、缓存等。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">joinPoint.getSignature().getDeclaringTypeName() 可以获取到调用方法的类名（包括包名），</div><div class="line">joinPoint.getSignature().getName()    可以获取方法名，</div><div class="line">Arrays.toString(joinPoint.getArgs())   得到的是方法调用的参数列表，</div><div class="line">joinPoint.proceed()   可以得到方法的返回结果</div></pre></td></tr></table></figure></p>
<h1 id="2-注解开发"><a href="#2-注解开发" class="headerlink" title="2.注解开发"></a>2.注解开发</h1><p>声明一个切面，只需要在类名上添加@Aspect属性即可，具体的连接点，我们用@Pointcut和@Before、@After等标注。<br>在声明前 我们需要依赖配置pom<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;dependency<span class="string">&gt;</span></div><div class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.11&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.11&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>例子<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.ganji.demo.service.aspect;</div><div class="line"></div><div class="line">import org.aspectj.lang.ProceedingJoinPoint;</div><div class="line">import org.aspectj.lang.annotation.*;</div><div class="line">import org.springframework.stereotype.Service;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by admin on <span class="number">2015</span>/<span class="number">9</span>/<span class="number">2.</span></div><div class="line"> */</div><div class="line">@Aspect</div><div class="line">@Service</div><div class="line">public class XmlAopDemoUserLog &#123;</div><div class="line"></div><div class="line">// 配置切点 及要传的参数   </div><div class="line">    @Pointcut(<span class="string">"execution(* com.ganji.demo.service.user.UserService.GetDemoUser(..)) &amp;&amp; args(id)"</span>)</div><div class="line">    public void pointCut(int id)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 配置连接点 方法开始执行时通知</div><div class="line">    @Before(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public void beforeLog(int id) &#123;</div><div class="line">        System.out.println(<span class="string">"开始执行前置通知  日志记录:"</span>+id);</div><div class="line">    &#125;</div><div class="line">//    方法执行完后通知</div><div class="line">    @After(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public void afterLog(int id) &#123;</div><div class="line">        System.out.println(<span class="string">"开始执行后置通知 日志记录:"</span>+id);</div><div class="line">    &#125;</div><div class="line">//    执行成功后通知</div><div class="line">    @AfterReturning(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public void afterReturningLog(int id) &#123;</div><div class="line">        System.out.println(<span class="string">"方法成功执行后通知 日志记录:"</span>+id);</div><div class="line">    &#125;</div><div class="line">//    抛出异常后通知</div><div class="line">    @AfterThrowing(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public void afterThrowingLog(int id) &#123;</div><div class="line">        System.out.println(<span class="string">"方法抛出异常后执行通知 日志记录"</span>+id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//    环绕通知</div><div class="line">    @Around(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public Object aroundLog(ProceedingJoinPoint joinpoint,int id) &#123;</div><div class="line">        Object result = <span class="literal">null</span>;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(<span class="string">"环绕通知开始 日志记录"</span>+id);</div><div class="line">            long start = System.currentTimeMillis();</div><div class="line"></div><div class="line">            //有返回参数 则需返回值</div><div class="line">            result =  joinpoint.proceed();</div><div class="line"></div><div class="line">            long end = System.currentTimeMillis();</div><div class="line">            System.out.println(<span class="string">"总共执行时长"</span> + (end - start) + <span class="string">" 毫秒"</span>);</div><div class="line">            System.out.println(<span class="string">"环绕通知结束 日志记录"</span>);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">            System.out.println(<span class="string">"出现错误"</span>);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="AOP切面中的同步问题"><a href="#AOP切面中的同步问题" class="headerlink" title="AOP切面中的同步问题"></a>AOP切面中的同步问题</h1><p>在WebLogAspect切面中，分别通过doBefore和doAfterReturning两个独立函数实现了切点头部和切点返回后执行的内容，<br>若我们想统计请求的处理时间，就需要在doBefore处记录时间，并在doAfterReturning处通过当前时间与开始处记录的时间计算<br>得到请求处理的消耗时间。<br>那么我们是否可以在WebLogAspect切面中定义一个成员变量来给doBefore和doAfterReturning一起访问呢？是否会有同步问题呢？<br>的确，直接在这里定义基本类型会有同步问题，所以我们可以引入ThreadLocal对象，像下面这样进行记录：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Aspect</div><div class="line">@Component</div><div class="line">public class WebLogAspect &#123;</div><div class="line"></div><div class="line">    private Logger logger = Logger.getLogger(getClass());</div><div class="line"></div><div class="line">    ThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    @Pointcut(<span class="string">"execution(public * com.juzi.web..*.*(..))"</span>)</div><div class="line">    public void webLog()&#123;&#125;</div><div class="line"></div><div class="line">    @Before(<span class="string">"webLog()"</span>)</div><div class="line">    public void doBefore(JoinPoint joinPoint) throws Throwable &#123;</div><div class="line">        startTime.set(System.currentTimeMillis());</div><div class="line"></div><div class="line">        // 省略日志记录内容</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @AfterReturning(returning = <span class="string">"ret"</span>, pointcut = <span class="string">"webLog()"</span>)</div><div class="line">    public void doAfterReturning(Object ret) throws Throwable &#123;</div><div class="line">        // 处理完请求，返回内容</div><div class="line">        logger.info(<span class="string">"RESPONSE : "</span> + ret);</div><div class="line">        logger.info(<span class="string">"SPEND TIME : "</span> + (System.currentTimeMillis() - startTime.get()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="AOP切面的优先级"><a href="#AOP切面的优先级" class="headerlink" title="AOP切面的优先级"></a>AOP切面的优先级</h1><p>由于通过AOP实现，程序得到了很好的解耦，但是也会带来一些问题，比如：我们可能会对Web层做多个切面，校验用户，<br>校验头信息等等，这个时候经常会碰到切面的处理顺序问题。</p>
<p>所以，我们需要定义每个切面的优先级，我们需要@Order(i)注解来标识切面的优先级。i的值越小，优先级越高。<br>假设我们还有一个切面是CheckNameAspect用来校验name必须为didi，我们为其设置@Order(10)，<br>而上文中WebLogAspect设置为@Order(5)，所以WebLogAspect有更高的优先级，这个时候执行顺序是这样的：</p>
<p>在@Before中优先执行@Order(5)的内容，再执行@Order(10)的内容<br>在@After和@AfterReturning中优先执行@Order(10)的内容，再执行@Order(5)的内容<br>所以我们可以这样子总结：</p>
<p>在切入点前的操作，按order的值由小到大执行<br>在切入点后的操作，按order的值由大到小执行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/07/28/spring-AOP-注解开发/" data-id="ciy1944550016zg9ojckcsyqo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-AOP/">spring AOP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Docker-应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/27/Docker-应用/" class="article-date">
  <time datetime="2016-07-27T09:20:21.000Z" itemprop="datePublished">2016-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/27/Docker-应用/">Docker 应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="应用Docker部署"><a href="#应用Docker部署" class="headerlink" title="应用Docker部署"></a>应用Docker部署</h1><p>在项目的根目录下建立一个Dockerfile文件<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">FROM maven:<span class="number">3.3</span><span class="number">.3</span>  </div><div class="line">  </div><div class="line">ADD pom.xml /tmp/build/  </div><div class="line">RUN cd /tmp/build &amp;&amp; mvn -q dependency:resolve  </div><div class="line">  </div><div class="line">ADD src /tmp/build/src  </div><div class="line">        <span class="comment">#构建应用  </span></div><div class="line">RUN cd /tmp/build &amp;&amp; mvn -q -DskipTests=<span class="literal">true</span> package \  </div><div class="line">        <span class="comment">#拷贝编译结果到指定目录  </span></div><div class="line">        &amp;&amp; mv target/*.jar /app.jar \  </div><div class="line">        <span class="comment">#清理编译痕迹  </span></div><div class="line">        &amp;&amp; cd / &amp;&amp; rm -rf /tmp/build  </div><div class="line">  </div><div class="line">VOLUME /tmp  </div><div class="line">EXPOSE <span class="number">8080</span>  </div><div class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</div></pre></td></tr></table></figure></p>
<p>因为 Spring Boot 框架打包的应用是一个包含依赖的 jar 文件，内嵌了 Tomcat 和 Jetty 支持，所以我们只需要使用包含 Java<br>的 Maven 镜像即可，不需要 Tomcat 镜像。<br>为了减少镜像大小，在执行 Maven 构建之后，清理了构建痕迹。<br>在 Dockerfile 文件的最后，使用 ENTRYPOINT 指令执行启动 Java 应用的操作。</p>
<h1 id="构建-Docker-镜像"><a href="#构建-Docker-镜像" class="headerlink" title="构建 Docker 镜像"></a>构建 Docker 镜像</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t docker-demo-spring-boot .   ／／注意后面的 . 表示当前路径下</div></pre></td></tr></table></figure>
<h1 id="从镜像启动容器"><a href="#从镜像启动容器" class="headerlink" title="从镜像启动容器"></a>从镜像启动容器</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p <span class="number">8080</span>:<span class="number">8080</span> docker-demo-spring-boot</div></pre></td></tr></table></figure>
<h1 id="完成部署："><a href="#完成部署：" class="headerlink" title="完成部署："></a>完成部署：</h1><p>URL访问，可通过docker ip查看应用的虚拟地址。</p>
<h1 id="Docker-Compose编排"><a href="#Docker-Compose编排" class="headerlink" title="Docker Compose编排"></a>Docker Compose编排</h1><p>Docker Compose是用于定义和组装运行多容器分布式应用的工具，<br>它提供一个简单的基于YAML语言的docker－compose.yml配置文件。 通常，我们使用docker定义和运行复杂的应用，<br>使用docker compose，在一个文件里定义多容器应用的启动顺序，起到服务编排的作用。</p>
<h2 id="编写-docker-compose-yaml-文件"><a href="#编写-docker-compose-yaml-文件" class="headerlink" title="编写 docker-compose.yaml 文件"></a>编写 docker-compose.yaml 文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">web:</span>  </div><div class="line"><span class="attr">  build:</span> .  </div><div class="line"><span class="attr">  ports:</span>  </div><div class="line"><span class="bullet">    -</span> <span class="string">"8080:8080"</span>  </div><div class="line"><span class="attr">  links:</span>  </div><div class="line"><span class="attr">    - mongodb:</span>mongodb  </div><div class="line">  </div><div class="line"><span class="attr">mongodb:</span>  </div><div class="line"><span class="attr">  image:</span> daocloud.io/library/mongo:latest  </div><div class="line"><span class="attr">  ports:</span>  </div><div class="line"><span class="bullet">    -</span> <span class="string">"27017:27017"</span></div></pre></td></tr></table></figure>
<p>这里以MongoDB数据库提供服务的demo，在该文件中，我们定于了两个服务：</p>
<pre><code>基于我们应用构建的 docker-demo-java-mongo 镜像，用来提供 Web 服务
基于 DaoCloud 提供的 MongoDB 镜像，提供存储服务
通过 links 为 web 关联 mongo 服务
</code></pre><h2 id="启动-Docker-Compose"><a href="#启动-Docker-Compose" class="headerlink" title="启动 Docker Compose"></a>启动 Docker Compose</h2><pre><code class="yaml">docker-compose up
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/07/27/Docker-应用/" data-id="ciy1944420005zg9ow0j2rw72" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring-Boot-Cloud2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/27/spring-Boot-Cloud2/" class="article-date">
  <time datetime="2016-07-27T07:39:34.000Z" itemprop="datePublished">2016-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/27/spring-Boot-Cloud2/">spring Boot Cloud2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-Cloud介绍"><a href="#Spring-Cloud介绍" class="headerlink" title="Spring Cloud介绍"></a>Spring Cloud介绍</h1><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、<br>智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>
<h1 id="Spring-Cloud与Dubbo对比"><a href="#Spring-Cloud与Dubbo对比" class="headerlink" title="Spring Cloud与Dubbo对比"></a>Spring Cloud与Dubbo对比</h1><p>它们两都具备分布式服务治理相关的功能，都能够提供服务注册、发现、路由、负载均衡等。说到这，Dubbo的功能好像<br>也就这么多了，但是Spring Cloud是提供了一整套企业级分布式云应用的完美解决方案，能够结合Spring Boot，<br>Docker实现快速开发的目的，所以说Dubbo只有Spring Cloud的一部分RPC功能，而且也谈不上谁好谁坏。不过，<br>Dubbo项目现已停止了更新，淘宝内部由hsf替代dubbo，我想这会有更多人倾向Spring Cloud了。<br>从开发角度上说，Dubbo常与Spring、zookeeper结合，而且实现只是通过xml来配置服务地址、名称、端口，<br>代码的侵入性是很小的，相对Spring Cloud，它的实现需要类注解等，多少具有一定侵入性。</p>
<h1 id="Spring-Cloud子项目"><a href="#Spring-Cloud子项目" class="headerlink" title="Spring Cloud子项目"></a>Spring Cloud子项目</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），之前在第一章节也介绍这些，</div><div class="line">比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud CloudFoundry、Spring Cloud AWS、</div><div class="line">Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。</div></pre></td></tr></table></figure>
<h2 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h2><p>Spring Cloud通过Netflix OSS的Eureka来实现服务发现，服务发现的主要目的是为了让每个服务之间可以互相通信。<br>Eureka Server为微服务的注册中心。谈到Spring Cloud Netflix，它是Spring Cloud的子项目之一，主要提供的模块包括：<br>服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。<br>Spring Cloud使用注解的方式提供了Eureka服务端（@EnableEurekaServer）和客户端（@EnableEurekaClient）。</p>
<h2 id="路由网关"><a href="#路由网关" class="headerlink" title="路由网关"></a>路由网关</h2><p>路由网关的主要目的是为了让所有的微服务对外只有一个接口，我们只需访问一个网关地址，即可由网关将所有的请求代理<br>到不同的服务中。Spring Cloud是通过Zuul来实现的，支持自动路由映射到在Eureka Server上注册的服务。<br>Spring Cloud提供了注解@EnableZuulProxy来启用路由代理。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Spring Cloud提供了Ribbon和Feign作为客户端的负载均衡。在Spring Cloud下，使用Ribbon直接注入一个RestTemplate<br>对象即可，此RestTemplate已做好负载均衡的配置；而使用Feign只需定义个注解，有@FeignClient注解的接口，<br>然后使用@RequestMapping注解在方法上映射远程的REST服务，此方法也是做好了负载均衡配置。</p>
<h2 id="路断器"><a href="#路断器" class="headerlink" title="路断器"></a>路断器</h2><p>断路器（Circuit Breaker）主要是为了解决当某个方法调用失败的时候，调用后备方法来替代失败的方法，<br>已达到容错／阻止级联错误的功能。Spring Cloud使用@EnableCircuitBreaker来启用断路器支持，<br>使用@HystrixCommand的fallbackMethod来指定后备方法。（@HystrixCommand(fallbackMethod=”fallbackOper”)）<br>Spring Cloud还提供了一个控制台来监控断路器的运行情况，通过@EnableHystrixDashboard注解开启。</p>
<p>Spring Cloud依赖<br><img src="/2016/07/27/spring-Boot-Cloud2/spring_cloud.jpg" alt="spring_cloud" title="spring_cloud"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/07/27/spring-Boot-Cloud2/" data-id="ciy194456001azg9o36okb189" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring-Boot-Cloud" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/27/spring-Boot-Cloud/" class="article-date">
  <time datetime="2016-07-27T06:43:26.000Z" itemprop="datePublished">2016-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/27/spring-Boot-Cloud/">spring Boot Cloud 学习1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-简介"><a href="#Spring-简介" class="headerlink" title="Spring 简介"></a>Spring 简介</h1><img src="/2016/07/27/spring-Boot-Cloud/Spring.jpg" alt="Spring Project" title="Spring Project">
<p>Spring IO platform:用于系统部署，是可集成的，构建现代化应用的版本平台，具体来说当你使用maven dependency引入spring jar包时它就在工作了。</p>
<p>Spring Boot:旨在简化创建产品级的 Spring 应用和服务，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用微服务功能，可以和spring cloud联合部署。</p>
<p>Spring Framework:即通常所说的spring 框架，是一个开源的Java/Java EE全功能栈应用程序框架，其它spring项目如spring boot也依赖于此框架。</p>
<p>Spring Cloud：微服务工具包，为开发者提供了在分布式系统的配置管理、服务发现、断路器、智能路由、微代理、控制总线等开发工具包。</p>
<p>Spring XD：是一种运行时环境（服务器软件，非开发框架），组合spring技术，如spring batch、spring boot、spring data，采集大数据并处理。</p>
<p>Spring Data：是一个数据访问及操作的工具包，封装了很多种数据及数据库的访问相关技术，包括：jdbc、Redis、MongoDB、Neo4j等。</p>
<p>Spring Batch：批处理框架，或说是批量任务执行管理器，功能包括任务调度、日志记录/跟踪等。</p>
<p>Spring Security：是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。</p>
<p>Spring Integration：面向企业应用集成（EAI/ESB）的编程框架，支持的通信方式包括HTTP、FTP、TCP/UDP、JMS、RabbitMQ、Email等。</p>
<p>Spring Social：一组工具包，一组连接社交服务API，如Twitter、Facebook、LinkedIn、GitHub等，有几十个。</p>
<p>Spring AMQP：消息队列操作的工具包，主要是封装了RabbitMQ的操作。</p>
<p>Spring HATEOAS：是一个用于支持实现超文本驱动的 REST Web 服务的开发库。</p>
<p>Spring Mobile：是Spring MVC的扩展，用来简化手机上的Web应用开发。</p>
<p>Spring for Android：是Spring框架的一个扩展，其主要目的在乎简化Android本地应用的开发，提供RestTemplate来访问Rest服务。</p>
<p>Spring Web Flow：目标是成为管理Web应用页面流程的最佳方案，将页面跳转流程单独管理，并可配置。</p>
<p>Spring LDAP：是一个用于操作LDAP的Java工具包，基于Spring的JdbcTemplate模式，简化LDAP访问。</p>
<p>Spring Session：session管理的开发工具包，让你可以把session保存到redis等，进行集群化session管理。</p>
<p>Spring Web Services：是基于Spring的Web服务框架，提供SOAP服务开发，允许通过多种方式创建Web服务。</p>
<p>Spring Shell：提供交互式的Shell可让你使用简单的基于Spring的编程模型来开发命令，比如Spring Roo命令。</p>
<p>Spring Roo：是一种Spring开发的辅助工具，使用命令行操作来生成自动化项目，操作非常类似于Rails。</p>
<p>Spring Scala：为Scala语言编程提供的spring框架的封装（新的编程语言，Java平台的Scala于2003年底/2004年初发布）。</p>
<p>Spring BlazeDS Integration：一个开发RIA工具包，可以集成Adobe Flex、BlazeDS、Spring以及Java技术创建RIA。</p>
<p>Spring Loaded：用于实现java程序和web应用的热部署的开源工具。</p>
<p>Spring REST Shell：可以调用Rest服务的命令行工具，敲命令行操作Rest服务。</p>
        
          <p class="article-more-link">
            <a href="/2016/07/27/spring-Boot-Cloud/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/07/27/spring-Boot-Cloud/" data-id="ciy1944560018zg9o39hlnazy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Codis/">Codis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EnableJpaRepositorie注解/">EnableJpaRepositorie注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Heroku/">Heroku</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JaveWeb/">JaveWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheduler/">Scheduler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Data-Jpa/">Spring Data Jpa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Security/">Spring Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/log4j/">log4j</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logback/">logback</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-AOP/">spring AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异常处理/">异常处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拦截器/">拦截器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/日志/">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随记/">随记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Codis/" style="font-size: 10px;">Codis</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/EnableJpaRepositorie注解/" style="font-size: 10px;">EnableJpaRepositorie注解</a> <a href="/tags/Heroku/" style="font-size: 10px;">Heroku</a> <a href="/tags/Java基础/" style="font-size: 10px;">Java基础</a> <a href="/tags/JaveWeb/" style="font-size: 10px;">JaveWeb</a> <a href="/tags/Kafka/" style="font-size: 10px;">Kafka</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Scheduler/" style="font-size: 12.5px;">Scheduler</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 17.5px;">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 20px;">Spring Cloud</a> <a href="/tags/Spring-Data-Jpa/" style="font-size: 10px;">Spring Data Jpa</a> <a href="/tags/Spring-Security/" style="font-size: 10px;">Spring Security</a> <a href="/tags/log4j/" style="font-size: 10px;">log4j</a> <a href="/tags/logback/" style="font-size: 10px;">logback</a> <a href="/tags/spring-AOP/" style="font-size: 10px;">spring AOP</a> <a href="/tags/异常处理/" style="font-size: 10px;">异常处理</a> <a href="/tags/拦截器/" style="font-size: 10px;">拦截器</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/编码/" style="font-size: 10px;">编码</a> <a href="/tags/随记/" style="font-size: 10px;">随记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/01/17/ScheduledThreadPoolExecutor的使用/">ScheduledThreadPoolExecutor的使用</a>
          </li>
        
          <li>
            <a href="/2016/12/31/才觉远去，便起回忆/">2016、才觉远去，便起怀念</a>
          </li>
        
          <li>
            <a href="/2016/12/31/Java设计模式/">Java设计模式</a>
          </li>
        
          <li>
            <a href="/2016/11/25/分布式系统/">分布式系统</a>
          </li>
        
          <li>
            <a href="/2016/10/24/spring-kafak集成学习/">spring-kafak集成学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>