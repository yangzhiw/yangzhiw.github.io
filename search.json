<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Kafka入门]]></title>
      <url>https://yangzhiw.github.io/2016/08/23/Kafkar%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kafka是一个分布式的、可分区的、可复制的消息系统。它提供了普通消息系统的功能，但具有自己独特的设计。<br>首先让我们看几个基本的消息系统术语：<br>Kafka将消息以topic为单位进行归纳。<br>将向Kafka topic发布消息的程序成为producers.<br>将预订topics并消费消息的程序成为consumer.<br>Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个broker.<br><img src="/2016/08/23/Kafkar入门/kafka1.jpg" alt="kafak架构" title="kafak架构"></p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>每个分区在Kafka集群的若干服务中都有副本，这样这些持有副本的服务可以共同处理数据和请求，副本数量是可以配置的。副本使Kafka具备了容错能力。<br>每个分区都由一个服务器作为“leader”，零或若干服务器作为“followers”,leader负责处理消息的读和写，followers则去复制leader.如果leader down了，<br>followers中的一台则会自动成为leader。集群中的每个服务都会同时扮演两个角色：<br>作为它所持有的一部分分区的leader，同时作为其他分区的followers，这样集群就会据有较好的负载均衡。</p>
<h2 id="Producers"><a href="#Producers" class="headerlink" title="Producers"></a>Producers</h2><p>Producer将消息发布到它指定的topic中,并负责决定发布到哪个分区。通常简单的由负载均衡机制随机选择分区，但也可以通过特定的分区函数选择分区。<br>使用的更多的是第二种。</p>
<h2 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h2><p>发布消息通常有两种模式：队列模式（queuing）和发布-订阅模式(publish-subscribe)。队列模式中，consumers可以同时从服务端读取<br>消息，每个消息只被其中一个consumer读到；发布-订阅模式中消息被广播到所有的consumer中。Consumers可以加入一个consumer<br>组，共同竞争一个topic，topic中的消息将被分发到组中的一个成员中。同一组中的consumer可以在不同的程序中，也可以在不同的<br>机器上。如果所有的consumer都在一个组中，这就成为了传统的队列模式，在各consumer中实现负载均衡。如果所有的consumer<br>不在不同的组中，这就成为了发布-订阅模式，所有的消息都被分发到所有的consumer中。更常见的是，每个topic都有若干数量<br>的consumer组，每个组都是一个逻辑上的“订阅者”，为了容错和更好的稳定性，每个组由若干consumer组成。这其实就是一个<br>发布-订阅模式，只不过订阅者是个组而不是单个consumer。<br><img src="/2016/08/23/Kafkar入门/kafka2.jpg" alt="kafakx消费组" title="kafakx消费组"><br>由两个机器组成的集群拥有4个分区 (P0-P3) 2个consumer组. A组有两个consumerB组有4个<br>相比传统的消息系统，Kafka可以很好的保证有序性。<br>传统的队列在服务器上保存有序的消息，如果多个consumers同时从这个服务器消费消息，服务器就会以消息存储的顺序向<br>consumer分发消息。虽然服务器按顺序发布消息，但是消息是被异步的分发到各consumer上，所以当消息到达时可能已经失去了<br>原来的顺序，这意味着并发消费将导致顺序错乱。为了避免故障，这样的消息系统通常使用“专用consumer”的概念，其实就是<br>只允许一个消费者消费消息，当然这就意味着失去了并发性。<br>在这方面Kafka做的更好，通过分区的概念，Kafka可以在多个consumer组并发的情况下提供较好的有序性和负载均衡。<br>将每个分区分只分发给一个consumer组，这样一个分区就只被这个组的一个consumer消费，就可以顺序的消费这个分区的消息。<br>为有多个分区，依然可以在多个consumer组之间进行负载均衡。注意consumer组的数量不能多于分区的数量，也就是有多少<br>分区就允许多少并发消费。<br>Kafka只能保证一个分区之内消息的有序性，在不同的分区之间是不可以的，这已经可以满足大部分应用的需求。<br>如果需要topic中所有消息的有序性，那就只能让这个topic只有一个分区，当然也就只有一个consumer组消费它。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="下载并解压"><a href="#下载并解压" class="headerlink" title="下载并解压"></a>下载并解压</h2><p>从<a href="http://kafka.apache.org/downloads.html" target="_blank" rel="external">官网</a>选择下载最新的二进制文件<br>解压<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar -vxzf kafka_2<span class="number">.11</span><span class="bullet">-0.10</span><span class="number">.0</span><span class="number">.1</span>.tgz</div><div class="line">cd kafka_2<span class="number">.11</span><span class="bullet">-0.10</span><span class="number">.0</span><span class="number">.1</span></div></pre></td></tr></table></figure></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>1.启动zookeeper<br>2.启动kafka<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-server-start.sh config/server.properties</div></pre></td></tr></table></figure></p>
<p>3.创建topic<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">使用kafka-topics.sh 创建单分区单副本的topic test：</div><div class="line">bin/kafka-topics.sh --create --zookeeper localhost:<span class="number">2181</span> --replication-factor <span class="number">1</span> --partitions <span class="number">1</span> --topic test</div><div class="line">查看</div><div class="line">bin/kafka-topics.sh --list --zookeeper localhost:<span class="number">2181</span></div><div class="line">test</div></pre></td></tr></table></figure></p>
<p>4.产生消息<br>使用kafka-console-producer.sh 发送消息：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bin/kafka-console-producer.sh --broker-list localhost:<span class="number">9092</span> --topic test </div><div class="line">Hello world！</div><div class="line">Hello Kafka！</div></pre></td></tr></table></figure></p>
<p>按Ctrl+C退出<br>5.消费消息<br>使用kafka-console-consumer.sh 接收消息并在终端打印：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bin/kafka-console-consumer.sh --zookeeper localhost:<span class="number">2181</span> --topic test --from-beginning</div><div class="line">Hello world!</div><div class="line">Hello Kafka!</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h1 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h1><h2 id="单机多broker-集群配置"><a href="#单机多broker-集群配置" class="headerlink" title="单机多broker 集群配置"></a>单机多broker 集群配置</h2><p>利用单节点部署多个broker。 不同的broker 设置不同的 id，监听端口及日志目录。 例如：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp config/server.properties config/server<span class="bullet">-1.</span>properties </div><div class="line">cp config/server.properties config/server<span class="bullet">-2.</span>properties</div></pre></td></tr></table></figure></p>
<p>编辑配置<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">config/server<span class="bullet">-1.</span>properties:</div><div class="line">    broker.id=<span class="number">1</span></div><div class="line">    port=<span class="number">9093</span></div><div class="line">    log.dir=/tmp/kafka-logs<span class="bullet">-1</span></div><div class="line">config/server<span class="bullet">-2.</span>properties:</div><div class="line">    broker.id=<span class="number">2</span></div><div class="line">    port=<span class="number">9094</span></div><div class="line">    log.dir=/tmp/kafka-logs<span class="bullet">-2</span></div></pre></td></tr></table></figure></p>
<p>启动Kafka服务：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bin/kafka-server-start.sh config/server<span class="bullet">-1.</span>properties &amp;</div><div class="line">bin/kafka-server-start.sh config/server<span class="bullet">-2.</span>properties &amp;</div></pre></td></tr></table></figure></p>
<p>创建一个拥有3个副本的topic:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --create --zookeeper localhost:<span class="number">2181</span> --replication-factor <span class="number">3</span> --partitions <span class="number">1</span> --topic my-replicated-topic</div></pre></td></tr></table></figure></p>
<p>现在我们搭建了一个集群，怎么知道每个节点的信息呢？运行“describe topics”命令就可以了：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --describe --zookeeper localhost:<span class="number">2181</span> --topic my-replicated-topic</div><div class="line"></div><div class="line">显示</div><div class="line"><span class="attr">Topic:</span>my-replicated-topic       PartitionCount:<span class="number">1</span>        ReplicationFactor:<span class="number">3</span>     Configs:</div><div class="line"><span class="attr">        Topic:</span> my-replicated-topic      Partition: <span class="number">0</span>    Leader: <span class="number">1</span>       Replicas: <span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span> Isr: <span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>下面解释一下这些输出。第一行是对所有分区的一个描述，然后每个分区都会对应一行，因为我们只有一个分区所以下面就只加了一行。<br>leader：负责处理消息的读和写，leader是从所有节点中随机选择的.<br>replicas：列出了所有的副本节点，不管节点是否在服务中.<br>isr：是正在服务中的节点.<br>在我们的例子中，节点1是作为leader运行。<br>向topic发送消息：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-console-producer.sh --broker-list localhost:<span class="number">9092</span> --topic my-replicated-topic</div></pre></td></tr></table></figure></p>
<p>my test message 1<br>my test message 2<br>消费者接受这些消息<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; bin/kafka-console-consumer.sh --zookeeper localhost:<span class="number">2181</span> --from-beginning --topic my-replicated-topic</div></pre></td></tr></table></figure></p>
<p>测试一下容错能力.Broker 1作为leader运行，现在我们kill掉它：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; ps | grep server<span class="bullet">-1.</span>properties7564 ttys002    <span class="number">0</span>:<span class="number">15.91</span> /System/Library/Frameworks/JavaVM.framework/Versions/<span class="number">1.6</span>/Home/bin/java...</div><div class="line">&gt; kill <span class="bullet">-9</span> <span class="number">7564</span></div></pre></td></tr></table></figure></p>
<p>另外一个节点被选做了leader,node 1 不再出现在 in-sync 副本列表中：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --describe --zookeeper localhost:<span class="number">218192</span> --topic my-replicated-topic</div><div class="line"><span class="attr">Topic:</span>my-replicated-topic       PartitionCount:<span class="number">1</span>        ReplicationFactor:<span class="number">3</span>     Configs:</div><div class="line"><span class="attr">        Topic:</span> my-replicated-topic      Partition: <span class="number">0</span>    Leader: <span class="number">2</span>       Replicas: <span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span> Isr: <span class="number">2</span>,<span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>虽然最初负责续写消息的leader down掉了，但之前的消息还是可以消费的.</p>
<h2 id="多机多broker-集群配置"><a href="#多机多broker-集群配置" class="headerlink" title="多机多broker 集群配置"></a>多机多broker 集群配置</h2><p>分别在多个节点按上述方式安装Kafka，配置启动多个Zookeeper 实例。<br>例如： 在10.4.253.22，10.4.253.23，10.4.253.24三台机器部署，Zookeeper配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">initLimit=<span class="number">5</span></div><div class="line">syncLimit=<span class="number">2</span></div><div class="line">server<span class="number">.1</span>=<span class="number">10.4</span><span class="number">.253</span><span class="number">.22</span>:<span class="number">2888</span>:<span class="number">3888</span></div><div class="line">server<span class="number">.2</span>=<span class="number">10.4</span><span class="number">.253</span><span class="number">.23</span>:<span class="number">2888</span>:<span class="number">3888</span></div><div class="line">server<span class="number">.3</span>=<span class="number">10.4</span><span class="number">.253</span><span class="number">.24</span>:<span class="number">2888</span>:<span class="number">3888</span></div></pre></td></tr></table></figure></p>
<p>分别配置多个机器上的Kafka服务 设置不同的broke id，zookeeper.connect设置如下:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zookeeper.connect=<span class="number">10.4</span><span class="number">.253</span><span class="number">.22</span>:<span class="number">2181</span>,<span class="number">10.4</span><span class="number">.253</span><span class="number">.23</span>:<span class="number">2181</span>,<span class="number">10.4</span><span class="number">.253</span><span class="number">.24</span>:<span class="number">2181</span></div></pre></td></tr></table></figure></p>
<p>启动Zookeeper与Kafka服务，按上文方式产生和消费消息，验证集群功能(本人未验证)。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Redis做集中式缓存]]></title>
      <url>https://yangzhiw.github.io/2016/08/19/%E4%BD%BF%E7%94%A8Redis%E5%81%9A%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sporing Boot中使用log4j记录日志]]></title>
      <url>https://yangzhiw.github.io/2016/08/19/Boot%E4%B8%AD%E4%BD%BF%E7%94%A8log4j%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<h1 id="引入log4j依赖"><a href="#引入log4j依赖" class="headerlink" title="引入log4j依赖"></a>引入log4j依赖</h1><p>在创建Spring Boot工程时，我们引入了spring-boot-starter，其中包含了spring-boot-starter-logging，该依赖内容就是<br>Spring Boot默认的日志框架Logback，所以我们在引入log4j之前，需要先排除该包的依赖，再引入log4j的依赖，就像下面这样：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;dependency<span class="string">&gt;  </span></div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</div><div class="line">    &lt;exclusions&gt;</div><div class="line">        &lt;exclusion&gt; </div><div class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</div><div class="line">        &lt;/exclusion&gt;</div><div class="line">    &lt;/exclusions&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;dependency&gt;  </div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h1 id="配置log4j-properties"><a href="#配置log4j-properties" class="headerlink" title="配置log4j.properties"></a>配置log4j.properties</h1><p>在引入了log4j依赖之后，只需要在src/main/resources目录下加入log4j.properties配置文件，就可以开始对应用的日志进行配置使用。</p>
<h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>通过如下配置，设定root日志的输出级别为INFO，appender为控制台输出stdout</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># LOG4J配置</span></div><div class="line">log4j.rootCategory=INFO, stdout</div><div class="line"></div><div class="line"><span class="comment"># 控制台输出</span></div><div class="line">	log4j.appender.stdout=org.apache.log4j.ConsoleAppender  </div><div class="line">	log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  </div><div class="line">	log4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %<span class="number">5</span>p %c&#123;<span class="number">1</span>&#125;:%L - %m%n</div></pre></td></tr></table></figure>
<h2 id="输出到文件"><a href="#输出到文件" class="headerlink" title="输出到文件"></a>输出到文件</h2><p>在开发环境，我们只是输出到控制台没有问题，但是到了生产或测试环境，或许持久化日志内容，方便追溯问题原因。<br>可以通过添加如下的appender内容，按天输出到不同的文件中去，同时还需要为log4j.rootCategory添加名为file的appender，<br>这样root日志就可以输出到logs/all.log文件中了。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#</span></div><div class="line">log4j.rootCategory=INFO, stdout, file</div><div class="line"></div><div class="line"><span class="comment"># root日志输出</span></div><div class="line">log4j.appender.file=org.apache.log4j.DailyRollingFileAppender  </div><div class="line">log4j.appender.file.file=logs/all.log  </div><div class="line">log4j.appender.file.DatePattern=<span class="string">'.'</span>yyyy-MM-dd  </div><div class="line">log4j.appender.file.layout=org.apache.log4j.PatternLayout  </div><div class="line">log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %<span class="number">5</span>p %c&#123;<span class="number">1</span>&#125;:%L - %m%n</div></pre></td></tr></table></figure></p>
<h2 id="分类输出"><a href="#分类输出" class="headerlink" title="分类输出"></a>分类输出</h2><p>1.可以按不同package进行输出。通过定义输出到logs/my.log的appender，并对com.didispace包下的日志级别设定<br>为DEBUG级别、appender设置为输出到logs/my.log的名为didifile的appender。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># com.juzi包下的日志配置</span></div><div class="line">log4j.category.com.juzi=DEBUG, didifile</div><div class="line"></div><div class="line"><span class="comment"># com.didispace下的日志输出</span></div><div class="line">log4j.appender.didifile=org.apache.log4j.DailyRollingFileAppender  </div><div class="line">log4j.appender.didifile.file=logs/my.log  </div><div class="line">log4j.appender.didifile.DatePattern=<span class="string">'.'</span>yyyy-MM-dd  </div><div class="line">log4j.appender.didifile.layout=org.apache.log4j.PatternLayout  </div><div class="line">log4j.appender.didifile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %<span class="number">5</span>p %c&#123;<span class="number">1</span>&#125;:%L ---- %m%n</div></pre></td></tr></table></figure></p>
<p>可以对不同级别进行分类，比如对ERROR级别输出到特定的日志文件中，具体配置可以如下。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">og4j.logger.error=errorfile  </div><div class="line"><span class="comment"># error日志输出</span></div><div class="line">log4j.appender.errorfile=org.apache.log4j.DailyRollingFileAppender  </div><div class="line">log4j.appender.errorfile.file=logs/error.log  </div><div class="line">log4j.appender.errorfile.DatePattern=<span class="string">'.'</span>yyyy-MM-dd  </div><div class="line">log4j.appender.errorfile.Threshold = ERROR  </div><div class="line">log4j.appender.errorfile.layout=org.apache.log4j.PatternLayout  </div><div class="line">log4j.appender.errorfile.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; %<span class="number">5</span>p %c&#123;<span class="number">1</span>&#125;:%L - %m%n</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot日志管理]]></title>
      <url>https://yangzhiw.github.io/2016/08/19/Boot%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Spring Boot在所有内部日志中使用Commons Logging，但是默认配置也提供了对常用日志的支持，<br>如：Java Util Logging，Log4J, Log4J2和Logback。每种Logger都可以通过配置使用控制台或者文件输出日志内容。</p>
<h1 id="日志输出格式"><a href="#日志输出格式" class="headerlink" title="日志输出格式"></a>日志输出格式</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">2016</span><span class="bullet">-08</span><span class="bullet">-19</span> <span class="number">10</span>:<span class="number">22</span>:<span class="number">04.233</span>  INFO <span class="number">7368</span> --- [           main] com.juzi.AsyncTest                       : Started AsyncTest in <span class="number">10.084</span> seconds (JVM running for <span class="number">12.545</span>)</div></pre></td></tr></table></figure>
<p>输出内容元素具体如下：</p>
<p>时间日期 — 精确到毫秒<br>日志级别 — ERROR, WARN, INFO, DEBUG or TRACE<br>进程ID<br>分隔符 — — 标识实际日志的开始<br>线程名 — 方括号括起来（可能会截断控制台输出）<br>Logger名 — 通常使用源代码的类名<br>日志内容</p>
<h1 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h1><p>在Spring Boot中默认配置了ERROR、WARN和INFO级别的日志输出到控制台。</p>
<p>我们可以通过两种方式切换至DEBUG级别：<br>1.在运行命令后加入–debug标志，如：$ java -jar myapp.jar –debug<br>2.在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）<br>会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。</p>
<h1 id="多彩输出"><a href="#多彩输出" class="headerlink" title="多彩输出"></a>多彩输出</h1><p>如果你的终端支持ANSI，设置彩色输出会让日志更具可读性。通过在application.properties中设置spring.output.ansi.enabled参数来支持。</p>
<p>1.NEVER：禁用ANSI-colored输出（默认项）<br>2.DETECT：会检查终端是否支持ANSI，是的话就采用彩色输出（推荐项）<br>3.ALWAYS：总是使用ANSI-colored格式输出，若终端不支持的时候，会有很多干扰信息，不推荐使用</p>
<h1 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h1><p>Spring Boot默认配置只会输出到控制台，并不会记录到文件中，但是我们通常生产环境使用时都需要以文件方式记录。</p>
<p>若要增加文件输出，需要在application.properties中配置logging.file或logging.path属性。</p>
<p>1.logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log<br>2.logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log</p>
<p>日志文件会在10Mb大小的时候被截断，产生新的日志文件，默认级别为：ERROR、WARN、INFO *</p>
<h1 id="级别控制"><a href="#级别控制" class="headerlink" title="级别控制"></a>级别控制</h1><p>在Spring Boot中只需要在application.properties中进行配置完成日志记录的级别控制。</p>
<p>配置格式：logging.level.*=LEVEL</p>
<p>1.logging.level：日志级别控制前缀，*为包名或Logger名<br>2.LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF<br>举例：</p>
<p>logging.level.com.juzi=DEBUG     com.juzi包下所有class以DEBUG级别输出<br>logging.level.root=WARN      root日志以WARN级别输出</p>
<h1 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h1><p>由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。<br>因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。</p>
<p>根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：</p>
<p>1.Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy    <a href="2016/07/21/logback">logback日志配置</a><br>2.Log4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml<br>3.Log4j2：log4j2-spring.xml, log4j2.xml<br>4.JDK (Java Util Logging)：logging.properties</p>
<p>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml）</p>
<h1 id="自定义输出格式"><a href="#自定义输出格式" class="headerlink" title="自定义输出格式"></a>自定义输出格式</h1><p>在Spring Boot中可以通过在application.properties配置如下参数控制输出格式：</p>
<p>1.logging.pattern.console：定义输出到控制台的样式（不支持JDK Logger）<br>2.logging.pattern.file：定义输出到文件的样式（不支持JDK Logger）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[@EnableJpaRepositories配置详解]]></title>
      <url>https://yangzhiw.github.io/2016/08/18/EnableJpaRepositories%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="1-简单配置"><a href="#1-简单配置" class="headerlink" title="1,简单配置"></a>1,简单配置</h1><p>@EnableJpaRepositories(“com.juzi.repository”)<br>或者 @EnableJpaRepositories({“com.juzi.repository”, “com.cshtong.second.repository”})</p>
<h1 id="2-完整的-EnableJpaRepositories注解"><a href="#2-完整的-EnableJpaRepositories注解" class="headerlink" title="2,完整的@EnableJpaRepositories注解"></a>2,完整的@EnableJpaRepositories注解</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> @EnableJpaRepositories(</div><div class="line">     basePackages = &#123;&#125;,</div><div class="line">     basePackageClasses = &#123;&#125;,</div><div class="line">     includeFilters = &#123;&#125;,</div><div class="line">     excludeFilters = &#123;&#125;,</div><div class="line">     repositoryImplementationPostfix = <span class="string">"Impl"</span>,</div><div class="line">     namedQueriesLocation = <span class="string">""</span>,//META-INF/jpa-named-queries.properties</div><div class="line">     queryLookupStrategy=QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND, //QueryLookupStrategy.Key.x</div><div class="line">     repositoryFactoryBeanClass=JpaRepositoryFactoryBean.class, //class</div><div class="line">     entityManagerFactoryRef=<span class="string">"entityManagerFactory"</span>,</div><div class="line">     transactionManagerRef=<span class="string">"transactionManager"</span>,</div><div class="line">     considerNestedRepositories=<span class="literal">false</span>, </div><div class="line">     enableDefaultTransactions=<span class="literal">true</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>各个配置项的作用<br>1）basePackage<br>用于配置扫描Repositories所在的package及子package。简单配置中的配置则等同于此项配置值，<br>basePackages可以配置为单个字符串，也可以配置为字符串数组形式。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@EnableJpaRepositories(</div><div class="line">        basePackages = <span class="string">"com.juzi"</span>)</div><div class="line">多个包路径</div><div class="line">@EnableJpaRepositories(</div><div class="line">        basePackages = &#123;<span class="string">"com.juzi.repository"</span>, <span class="string">"com.juzi.second.repository"</span>&#125;)</div></pre></td></tr></table></figure></p>
<p>2）basePackageClasses<br>指定 Repository 类<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@EnableJpaRepositories(basePackageClasses = BookRepository.class)</div><div class="line"></div><div class="line">@EnableJpaRepositories(</div><div class="line">         basePackageClasses = &#123;ShopRepository.class, OrganizationRepository.class&#125;)</div></pre></td></tr></table></figure></p>
<p>3）includeFilters<br>过滤器，该过滤区采用ComponentScan的过滤器类<br>@EnableJpaRepositories(<br>      includeFilters={@ComponentScan.Filter(type=FilterType.ANNOTATION, value=Repository.class)})<br>4）excludeFilters<br>不包含过滤器</p>
<p>@EnableJpaRepositories(<br>         excludeFilters={<br>                 @ComponentScan.Filter(type=FilterType.ANNOTATION, value=Service.class),<br>                 @ComponentScan.Filter(type=FilterType.ANNOTATION, value=Controller.class)})</p>
<p>5）repositoryImplementationPostfix<br>实现类追加的尾部，比如ShopRepository，对应的为ShopRepositoryImpl</p>
<p>6）namedQueriesLocation<br>named SQL存放的位置，默认为META-INF/jpa-named-queries.properties</p>
<p>7）queryLookupStrategy<br>构建条件查询的策略，包含三种方式CREATE，USE_DECLARED_QUERY，CREATE_IF_NOT_FOUND</p>
<p>CREATE：按照接口名称自动构建查询<br>USE_DECLARED_QUERY：用户声明查询<br>CREATE_IF_NOT_FOUND：先搜索用户声明的，不存在则自动构建</p>
<p>8）repositoryFactoryBeanClass<br>指定Repository的工厂类</p>
<p>9)entityManagerFactoryRef<br>实体管理工厂引用名称，对应到@Bean注解对应的方法</p>
<p>10)transactionManagerRef</p>
<p>事务管理工厂引用名称，对应到@Bean注解对应的方法</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring Boot中使用Spring Security进行安全控制]]></title>
      <url>https://yangzhiw.github.io/2016/08/17/Security%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%85%A8%E6%8E%A7%E5%88%B6/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb基础]]></title>
      <url>https://yangzhiw.github.io/2016/08/16/JavaWeb%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="1，Servlet-生命周期、工作原理"><a href="#1，Servlet-生命周期、工作原理" class="headerlink" title="1，Servlet 生命周期、工作原理"></a>1，Servlet 生命周期、工作原理</h1><p><a href="http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.html" target="_blank" rel="external">点我跳转</a></p>
<h1 id="2，JSP和Servlet的区别"><a href="#2，JSP和Servlet的区别" class="headerlink" title="2，JSP和Servlet的区别"></a>2，JSP和Servlet的区别</h1><p>jsp经过编译后变成类servlet，<br>jsp由html代码和jsp标签组成，擅长页面显示，servlet擅长流程控制；<br>JSP中嵌入JAVA代码，而Servlet中嵌入HTML代码。</p>
<h1 id="3，JSP的动态include和静态include"><a href="#3，JSP的动态include和静态include" class="headerlink" title="3，JSP的动态include和静态include"></a>3，JSP的动态include和静态include</h1><p>(1)动态include用jsp:include动作实现，如<jsp:include page="abc.jsp" flush="true">，<br>它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。会先解析所要包含的页面，解析后和主页面合并一起显示，即先编译后包含。<br>(2)静态include用include伪码实现，不会检查所含文件的变化，适用于包含静态页面，如&lt;%@ include file=”qq.htm” %&gt;，<br>不会提前解析所要包含的页面，先把要显示的页面包含进来，然后统一编译，即先包含后编译。</jsp:include></p>
<h1 id="4，设计模式的6大原则"><a href="#4，设计模式的6大原则" class="headerlink" title="4，设计模式的6大原则"></a>4，设计模式的6大原则</h1><p>(1)单一职责原则<br>    可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；<br>    提高类的可读性，提高系统的可维护性；<br>    变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p>
<p>(2)里氏替换原则<br>    子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>    子类中可以增加自己特有的方法。<br>    当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。<br>    当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p>
<p>(3)依赖倒置原则<br>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。<br>传递依赖关系的三种关系：<br>    接口传递<br>    构造方法传递<br>    setter方法传递<br>(4)接口隔离原则<br>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，<br>    则会造成接口数量过多，使设计复杂化。所以一定要适度。<br>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，<br>    才能建立最小的依赖关系。<br>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。<br>(5)迪米特法则<br>定义：一个对象应该对其他对象保持最少的了解。<br>(6)开闭原则<br>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<h1 id="4，Hibernate缓存：一级缓存和二级缓存"><a href="#4，Hibernate缓存：一级缓存和二级缓存" class="headerlink" title="4，Hibernate缓存：一级缓存和二级缓存"></a>4，Hibernate缓存：一级缓存和二级缓存</h1><p>Hibernate缓存的分类：<br>(1),Session缓存（又称事物缓存），Hibernate内置的，不能卸载；<br>缓存范围：缓存只能被当前Session对象访问。缓存的生命周期依赖于Session的生命周期，当Session被关闭后，缓存也就结束生命周期。<br>(2)SessionFactory缓存（又称作应用缓存）：使用第三方插件，可插拔.<br>缓存范围：缓存被应用范围内的所有session共享,不同的Session可以共享。这些session有可能是并发访问缓存，因此必须对缓存进行更新。<br>        缓存的生命周期依赖于应用的生命周期，应用结束时，缓存也就结束了生命周期，二级缓存存在于应用程序范围。</p>
<p>一级缓存：<br>(1). save()。当session对象调用save()方法保存一个对象后，该对象会被放入到session的缓存中。<br>(2). get()和load()。当session对象调用get()或load()方法从数据库取出一个对象后，该对象也会被放入到session的缓存中。<br>(3). 使用HQL和QBC等从数据库中查询数据。<br>数据从缓存中清除：<br>(1). evit()将指定的持久化对象从缓存中清除，释放对象所占用的内存资源，指定对象从持久化状态变为脱管状态，从而成为游离对象。<br>(2). clear()将缓存中的所有持久化对象清除，释放其占用的内存资源。<br>其他缓存操作：<br>(1). contains()判断指定的对象是否存在于缓存中。<br>(2). flush()刷新缓存区的内容，使之与数据库数据保持同步。</p>
<p>二级缓存：<br>定义：SessionFactory级别的缓存，可以跨越Session存在，可以被多个Session所共享。<br>实现原理：<br>Hibernate如何将数据库中的数据放入到二级缓存中？注意，你可以把缓存看做是一个Map对象，<br>它的Key用于存储对象OID，Value用于存储POJO。首先，当我们使用Hibernate从数据库中查询出数据，<br>获取检索的数据后，Hibernate将检索出来的对象的OID放入缓存中key 中，然后将具体的POJO放入value中，<br>等待下一次再次向数据查询数据时，Hibernate根据你提供的OID先检索一级缓存，若有且配置了二级缓存，则检索二级缓存，<br>如果还没有则才向数据库发送SQL语句，然后将查询出来的对象放入缓存中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络知识复习]]></title>
      <url>https://yangzhiw.github.io/2016/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring定时任务]]></title>
      <url>https://yangzhiw.github.io/2016/08/10/spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<h2 id="获取昨天时间"><a href="#获取昨天时间" class="headerlink" title="获取昨天时间"></a>获取昨天时间</h2><pre><code>Calendar c=Calendar.getInstance();
c.add(Calendar.DAY_OF_MONTH,-1);   //日期月是0-11
c.set(Calendar.HOUR_OF_DAY,0);     
c.set(Calendar.MINUTE,0);
c.set(Calendar.SECOND,0);
c.set(Calendar.MILLISECOND,0);
return c.getTime();
</code></pre><h2 id="在类上加上注解"><a href="#在类上加上注解" class="headerlink" title="在类上加上注解"></a>在类上加上注解</h2><p>@Configuration<br>@EnableScheduling<br>@Scheduled(fixedRate = 5000) ：上一次开始执行时间点之后5秒再执行<br>@Scheduled(fixedDelay = 5000) ：上一次执行完毕时间点之后5秒再执行<br>@Scheduled(initialDelay=1000, fixedRate=5000) ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次<br>@Scheduled(cron=”<em>/5 </em> <em> </em> <em> </em>“) ：通过cron表达式定义规则        </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[获取文件流编码]]></title>
      <url>https://yangzhiw.github.io/2016/08/10/%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81%E7%9A%84%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<h1 id="1，获取文件的流"><a href="#1，获取文件的流" class="headerlink" title="1，获取文件的流"></a>1，获取文件的流</h1><pre><code>InportStream importStream = file.getInputStream()；
</code></pre><h1 id="2，把文件流转化为字节流"><a href="#2，把文件流转化为字节流" class="headerlink" title="2，把文件流转化为字节流"></a>2，把文件流转化为字节流</h1><pre><code>//字节数组输出流
ByteArrayOutputStream baos = new ByteArrayOutputStream();
try {
    byte[] buffer = new byte[1024];
    int len;
    while ((len = inputStream.read(buffer)) &gt; -1) {
        baos.write(buffer, 0, len);
    }
    baos.flush();
}catch(IOException e){
    e.printStackTrace();
}
return new ByteArrayInputStream(baos.toByteArray());
</code></pre><h1 id="3，根据字节流的判断文件的编码"><a href="#3，根据字节流的判断文件的编码" class="headerlink" title="3，根据字节流的判断文件的编码"></a>3，根据字节流的判断文件的编码</h1><pre><code>//默认编码
String charset = &quot;GBK&quot;;
byte[] first3Bytes = new byte[3];
//缓存流
BufferedInputStream bis = new BufferedInputStream(inputStream1);
try {
    boolean checked = false;
    //标记
    bis.mark(0);
    //读取文件的前3个字符
    int read = bis.read(first3Bytes, 0, 3);
    if (read == -1) return charset;
    if (first3Bytes[0] == (byte) 0xFF &amp;&amp; first3Bytes[1] == (byte) 0xFE) {
        charset = &quot;UTF-16LE&quot;;
        checked = true;
    } else if (first3Bytes[0] == (byte) 0xFE &amp;&amp; first3Bytes[1] == (byte) 0xFF) {
        charset = &quot;UTF-16BE&quot;;
        checked = true;
    } else if (first3Bytes[0] == (byte) 0xEF &amp;&amp; first3Bytes[1] == (byte) 0xBB &amp;&amp; first3Bytes[2] == (byte) 0xBF) {
        charset = &quot;UTF-8&quot;;
        checked = true;
    }
    bis.reset();
    if (!checked) {

        int loc = 0;
        while ((read = bis.read()) != -1) {
            loc++;
            if (read &gt;= 0xF0) break;
            if (0x80 &lt;= read &amp;&amp; read &lt;= 0xBF) // 单独出现BF以下的，也算是GBK
                break;
            if (0xC0 &lt;= read &amp;&amp; read &lt;= 0xDF) {
                read = bis.read();
                if (0x80 &lt;= read &amp;&amp; read &lt;= 0xBF) // 双字节 (0xC0 - 0xDF) (0x80
                    continue;
                else break;
            } else if (0xE0 &lt;= read &amp;&amp; read &lt;= 0xEF) {// 也有可能出错，但是几率较小
                read = bis.read();
                if (0x80 &lt;= read &amp;&amp; read &lt;= 0xBF) {
                    read = bis.read();
                    if (0x80 &lt;= read &amp;&amp; read &lt;= 0xBF) {
                        charset = &quot;UTF-8&quot;;
                        break;
                    } else break;
                } else break;
            }
        }
    }
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        bis.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java 复习资料]]></title>
      <url>https://yangzhiw.github.io/2016/08/01/java-%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p>1，面向对象和面向过程的区别<br>2，java的三大特性</p>
<hr>
<pre><code>封装，继承，多态
</code></pre><p>3，OverLoad与Override的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   Override（重写，覆盖） </div><div class="line">方法名、参数、返回值相同。</div><div class="line">子类方法不能缩小父类方法的访问权限。</div><div class="line">子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</div><div class="line">存在于父类和子类之间。</div><div class="line">方法被定义为final不能被重写。</div><div class="line"></div><div class="line">   Overload（重载，过载）</div><div class="line">参数类型、个数、顺序至少有一个不相同。  </div><div class="line">不能重载只有返回值不同的方法名。</div><div class="line">存在于父类和子类、同类中。</div></pre></td></tr></table></figure></p>
<p>4，构造器不能被修饰Override<br>5，访问控制符public,protected,private,以及默认的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">作用域      当前类      同包   子类    其他</div><div class="line">public        √        √       √      √</div><div class="line">protected     √        √       √      ×</div><div class="line">default       √        √       ×      ×</div><div class="line">private       √        ×       ×      ×</div></pre></td></tr></table></figure></p>
<p>6，String和StringBuffer、StringBuilder的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">可变与不可变</div><div class="line">String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。</div><div class="line">private final char value[];</div><div class="line"></div><div class="line">StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符</div><div class="line">数组保存字符串，如下就是，可知这两种对象都是可变的。</div><div class="line"></div><div class="line">char[] value;</div><div class="line">线程是否安全</div><div class="line">StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</div><div class="line">StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</div></pre></td></tr></table></figure></p>
<p>7，抽象类和接口的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</div><div class="line"></div><div class="line">　　<span class="number">2</span>）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</div><div class="line"></div><div class="line">　　<span class="number">3</span>）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</div><div class="line"></div><div class="line">　　<span class="number">4</span>）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</div></pre></td></tr></table></figure></p>
<p>8，自动装箱与拆箱<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">基本数据类型的自动装箱(autoboxing)、拆箱(unboxing)是自J2SE <span class="number">5.0</span>开始提供的功能。 </div><div class="line">基本数据与对象的区别</div><div class="line">如：int t = <span class="number">1</span>；     t.  后面是没有方法滴。</div><div class="line"></div><div class="line">    Integer t =<span class="number">1</span>； t.  后面就有很多方法可让你调用了。</div><div class="line"></div><div class="line">Integer i = <span class="number">100</span>; // 自动装箱</div><div class="line">相当于编译器自动为您作以下的语法编译：Integer i = Integer.valueOf(<span class="number">100</span>);</div><div class="line">Integer i = <span class="number">10</span>; //装箱 </div><div class="line">int t = i; //拆箱，实际上执行了 int t = i.intValue();    </div><div class="line"></div><div class="line">注意：integer值得默认大小是<span class="bullet">-127</span><span class="bullet">-128</span></div></pre></td></tr></table></figure></p>
<p>7，泛型<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">泛型是Java SE <span class="number">1.5</span>的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数,</div><div class="line">类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，</div><div class="line">将泛型java代码直接转换成普通java字节码。</div><div class="line">     类型擦除的主要过程如下：</div><div class="line">     <span class="number">1.</span>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</div><div class="line">     <span class="number">2.</span>移除所有的类型参数。</div></pre></td></tr></table></figure></p>
<p>8,Java中的集合类及其关系图<br>关系图<br><img src="/2016/08/01/java-基础题/java_collection.jpg" alt="微服务架构图" title="微服务架构图"><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　上述类图中，实线边框的是实现类，比如ArrayList，LinkedList，HashMap等，</div><div class="line">  折线边框的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，</div><div class="line">  而点线边框的是接口，比如Collection，Iterator，List等。</div><div class="line">  	　		是否有序	是否允许元素重复</div><div class="line">Collection		否		是</div><div class="line">List			是		是</div><div class="line">Set	AbstractSet	否		否</div><div class="line">　	HashSet    	 否		否</div><div class="line">　	TreeSet		是		否</div><div class="line">Map	AbstractMap	否	使用key-value来映射和存储数据，key必须唯一，value可以重复</div><div class="line">　	HashMap</div><div class="line">　	TreeMap		是（用二叉排序树）</div></pre></td></tr></table></figure></p>
<p>9，HashMap的实现原理<br>   见此链接<br>10，HashTable实现原理<br>   见此链接<br>11，HashMap与HashTable的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">第一，继承不同。</div><div class="line"></div><div class="line">public class Hashtable extends Dictionary implements Map</div><div class="line">public class HashMap  extends AbstractMap implements Map</div><div class="line">第二</div><div class="line"></div><div class="line">Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</div><div class="line"></div><div class="line">第三</div><div class="line"></div><div class="line">Hashtable中，key和value都不允许出现<span class="literal">null</span>值。</div><div class="line"></div><div class="line">在HashMap中，<span class="literal">null</span>可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为<span class="literal">null</span>。当get()方法返回<span class="literal">null</span>值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为<span class="literal">null</span>。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</div><div class="line"></div><div class="line">第四，两个遍历方式的内部实现上不同。</div><div class="line"></div><div class="line">Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</div><div class="line"></div><div class="line">第五</div><div class="line"></div><div class="line">哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</div><div class="line"></div><div class="line">第六</div><div class="line"></div><div class="line">Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是<span class="number">11</span>，增加的方式是 old*<span class="number">2</span>+<span class="number">1</span>。HashMap中hash数组的默认大小是<span class="number">16</span>，而且一定是<span class="number">2</span>的指数。</div></pre></td></tr></table></figure></p>
<p>12，ArrayList和vector区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）  Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。 </div><div class="line"><span class="number">2</span>） 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加<span class="number">50</span>%的大小，这样,ArrayList就有利于节约内存空间。</div></pre></td></tr></table></figure></p>
<p>13,ArrayList和LinkedList区别及使用场景<br>区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ArryList初始化时，elementData数组大小默认为<span class="number">10</span>；</div><div class="line">每次add（）时，先调用ensureCapacity（）保证数组不会溢出，如果此时已满，会扩展为数组length的<span class="number">1.5</span>倍+<span class="number">1</span>，</div><div class="line">然后用array.copy的方法，将原数组拷贝到新的数组中；线程不安全。</div><div class="line"></div><div class="line">LinkedList是基于双链表实现的：</div><div class="line">使用header的优点是：在任何一个条目（包括第一个和最后一个）都有一个前置条目和一个后置条目，</div><div class="line">因此在LinkedList对象的开始或者末尾进行插入操作没有特殊的地方；</div></pre></td></tr></table></figure></p>
<p>使用场景<br>   （1）查询操作多，ArrayList对象要远优于LinkedList对象；</p>
<p>   （2）修改和删除操作多，LinkedList对象要远优于ArrayList对象；</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[spring AOP 注解开发]]></title>
      <url>https://yangzhiw.github.io/2016/07/28/spring-AOP-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><p>AOP主要包含了通知、切点和连接点等术语，介绍如下:</p>
<h2 id="通知（advice）"><a href="#通知（advice）" class="headerlink" title="通知（advice）"></a>通知（advice）</h2><p>通知定义了切面是什么以及何时调用，何时调用包含以下几种<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Before 在方法被调用之前调用通知</div><div class="line">After 在方法完成之后调用通知，无论方法执行是否成功</div><div class="line">After-returning 在方法成功执行之后调用通知</div><div class="line">After-throwing 在方法抛出异常后调用通知</div><div class="line">Around 通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</div></pre></td></tr></table></figure></p>
<h2 id="切点-PointCut"><a href="#切点-PointCut" class="headerlink" title="切点(PointCut)"></a>切点(PointCut)</h2><p>通知定义了切面的什么和何时，切点定义了何处，切点的定义会匹配通知所要织入的一个或多个连接点，<br>我们通常使用明确的类的方法名称来指定这些切点，或是利用正则表达式定义匹配的类和方法名称来指定这些切点。</p>
<h2 id="连接点-JoinPoint"><a href="#连接点-JoinPoint" class="headerlink" title="连接点(JoinPoint)"></a>连接点(JoinPoint)</h2><p>连接点是在应用执行过程中能够插入切面的一个点，这个点可以是调用方法时，抛出异常时，甚至是修改一个字段时，<br>切面代码可以利用这些连接点插入到应用的正常流程中，并添加新的行为，如日志、安全、事务、缓存等。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">joinPoint.getSignature().getDeclaringTypeName() 可以获取到调用方法的类名（包括包名），</div><div class="line">joinPoint.getSignature().getName()    可以获取方法名，</div><div class="line">Arrays.toString(joinPoint.getArgs())   得到的是方法调用的参数列表，</div><div class="line">joinPoint.proceed()   可以得到方法的返回结果</div></pre></td></tr></table></figure></p>
<h1 id="2-注解开发"><a href="#2-注解开发" class="headerlink" title="2.注解开发"></a>2.注解开发</h1><p>声明一个切面，只需要在类名上添加@Aspect属性即可，具体的连接点，我们用@Pointcut和@Before、@After等标注。<br>在声明前 我们需要依赖配置pom<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;dependency<span class="string">&gt;</span></div><div class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.11&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.6.11&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>例子<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">package com.ganji.demo.service.aspect;</div><div class="line"></div><div class="line">import org.aspectj.lang.ProceedingJoinPoint;</div><div class="line">import org.aspectj.lang.annotation.*;</div><div class="line">import org.springframework.stereotype.Service;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by admin on <span class="number">2015</span>/<span class="number">9</span>/<span class="number">2.</span></div><div class="line"> */</div><div class="line">@Aspect</div><div class="line">@Service</div><div class="line">public class XmlAopDemoUserLog &#123;</div><div class="line"></div><div class="line">// 配置切点 及要传的参数   </div><div class="line">    @Pointcut(<span class="string">"execution(* com.ganji.demo.service.user.UserService.GetDemoUser(..)) &amp;&amp; args(id)"</span>)</div><div class="line">    public void pointCut(int id)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 配置连接点 方法开始执行时通知</div><div class="line">    @Before(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public void beforeLog(int id) &#123;</div><div class="line">        System.out.println(<span class="string">"开始执行前置通知  日志记录:"</span>+id);</div><div class="line">    &#125;</div><div class="line">//    方法执行完后通知</div><div class="line">    @After(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public void afterLog(int id) &#123;</div><div class="line">        System.out.println(<span class="string">"开始执行后置通知 日志记录:"</span>+id);</div><div class="line">    &#125;</div><div class="line">//    执行成功后通知</div><div class="line">    @AfterReturning(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public void afterReturningLog(int id) &#123;</div><div class="line">        System.out.println(<span class="string">"方法成功执行后通知 日志记录:"</span>+id);</div><div class="line">    &#125;</div><div class="line">//    抛出异常后通知</div><div class="line">    @AfterThrowing(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public void afterThrowingLog(int id) &#123;</div><div class="line">        System.out.println(<span class="string">"方法抛出异常后执行通知 日志记录"</span>+id);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">//    环绕通知</div><div class="line">    @Around(<span class="string">"pointCut(id)"</span>)</div><div class="line">    public Object aroundLog(ProceedingJoinPoint joinpoint,int id) &#123;</div><div class="line">        Object result = <span class="literal">null</span>;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(<span class="string">"环绕通知开始 日志记录"</span>+id);</div><div class="line">            long start = System.currentTimeMillis();</div><div class="line"></div><div class="line">            //有返回参数 则需返回值</div><div class="line">            result =  joinpoint.proceed();</div><div class="line"></div><div class="line">            long end = System.currentTimeMillis();</div><div class="line">            System.out.println(<span class="string">"总共执行时长"</span> + (end - start) + <span class="string">" 毫秒"</span>);</div><div class="line">            System.out.println(<span class="string">"环绕通知结束 日志记录"</span>);</div><div class="line">        &#125; catch (Throwable t) &#123;</div><div class="line">            System.out.println(<span class="string">"出现错误"</span>);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="AOP切面中的同步问题"><a href="#AOP切面中的同步问题" class="headerlink" title="AOP切面中的同步问题"></a>AOP切面中的同步问题</h1><p>在WebLogAspect切面中，分别通过doBefore和doAfterReturning两个独立函数实现了切点头部和切点返回后执行的内容，<br>若我们想统计请求的处理时间，就需要在doBefore处记录时间，并在doAfterReturning处通过当前时间与开始处记录的时间计算<br>得到请求处理的消耗时间。<br>那么我们是否可以在WebLogAspect切面中定义一个成员变量来给doBefore和doAfterReturning一起访问呢？是否会有同步问题呢？<br>的确，直接在这里定义基本类型会有同步问题，所以我们可以引入ThreadLocal对象，像下面这样进行记录：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">@Aspect</div><div class="line">@Component</div><div class="line">public class WebLogAspect &#123;</div><div class="line"></div><div class="line">    private Logger logger = Logger.getLogger(getClass());</div><div class="line"></div><div class="line">    ThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;&gt;();</div><div class="line"></div><div class="line">    @Pointcut(<span class="string">"execution(public * com.juzi.web..*.*(..))"</span>)</div><div class="line">    public void webLog()&#123;&#125;</div><div class="line"></div><div class="line">    @Before(<span class="string">"webLog()"</span>)</div><div class="line">    public void doBefore(JoinPoint joinPoint) throws Throwable &#123;</div><div class="line">        startTime.set(System.currentTimeMillis());</div><div class="line"></div><div class="line">        // 省略日志记录内容</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @AfterReturning(returning = <span class="string">"ret"</span>, pointcut = <span class="string">"webLog()"</span>)</div><div class="line">    public void doAfterReturning(Object ret) throws Throwable &#123;</div><div class="line">        // 处理完请求，返回内容</div><div class="line">        logger.info(<span class="string">"RESPONSE : "</span> + ret);</div><div class="line">        logger.info(<span class="string">"SPEND TIME : "</span> + (System.currentTimeMillis() - startTime.get()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="AOP切面的优先级"><a href="#AOP切面的优先级" class="headerlink" title="AOP切面的优先级"></a>AOP切面的优先级</h1><p>由于通过AOP实现，程序得到了很好的解耦，但是也会带来一些问题，比如：我们可能会对Web层做多个切面，校验用户，<br>校验头信息等等，这个时候经常会碰到切面的处理顺序问题。</p>
<p>所以，我们需要定义每个切面的优先级，我们需要@Order(i)注解来标识切面的优先级。i的值越小，优先级越高。<br>假设我们还有一个切面是CheckNameAspect用来校验name必须为didi，我们为其设置@Order(10)，<br>而上文中WebLogAspect设置为@Order(5)，所以WebLogAspect有更高的优先级，这个时候执行顺序是这样的：</p>
<p>在@Before中优先执行@Order(5)的内容，再执行@Order(10)的内容<br>在@After和@AfterReturning中优先执行@Order(10)的内容，再执行@Order(5)的内容<br>所以我们可以这样子总结：</p>
<p>在切入点前的操作，按order的值由小到大执行<br>在切入点后的操作，按order的值由大到小执行</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker 应用]]></title>
      <url>https://yangzhiw.github.io/2016/07/27/Docker-%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="应用Docker部署"><a href="#应用Docker部署" class="headerlink" title="应用Docker部署"></a>应用Docker部署</h1><p>在项目的根目录下建立一个Dockerfile文件<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">FROM maven:<span class="number">3.3</span><span class="number">.3</span>  </div><div class="line">  </div><div class="line">ADD pom.xml /tmp/build/  </div><div class="line">RUN cd /tmp/build &amp;&amp; mvn -q dependency:resolve  </div><div class="line">  </div><div class="line">ADD src /tmp/build/src  </div><div class="line">        <span class="comment">#构建应用  </span></div><div class="line">RUN cd /tmp/build &amp;&amp; mvn -q -DskipTests=<span class="literal">true</span> package \  </div><div class="line">        <span class="comment">#拷贝编译结果到指定目录  </span></div><div class="line">        &amp;&amp; mv target/*.jar /app.jar \  </div><div class="line">        <span class="comment">#清理编译痕迹  </span></div><div class="line">        &amp;&amp; cd / &amp;&amp; rm -rf /tmp/build  </div><div class="line">  </div><div class="line">VOLUME /tmp  </div><div class="line">EXPOSE <span class="number">8080</span>  </div><div class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</div></pre></td></tr></table></figure></p>
<p>因为 Spring Boot 框架打包的应用是一个包含依赖的 jar 文件，内嵌了 Tomcat 和 Jetty 支持，所以我们只需要使用包含 Java<br>的 Maven 镜像即可，不需要 Tomcat 镜像。<br>为了减少镜像大小，在执行 Maven 构建之后，清理了构建痕迹。<br>在 Dockerfile 文件的最后，使用 ENTRYPOINT 指令执行启动 Java 应用的操作。</p>
<h1 id="构建-Docker-镜像"><a href="#构建-Docker-镜像" class="headerlink" title="构建 Docker 镜像"></a>构建 Docker 镜像</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t docker-demo-spring-boot .   ／／注意后面的 . 表示当前路径下</div></pre></td></tr></table></figure>
<h1 id="从镜像启动容器"><a href="#从镜像启动容器" class="headerlink" title="从镜像启动容器"></a>从镜像启动容器</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p <span class="number">8080</span>:<span class="number">8080</span> docker-demo-spring-boot</div></pre></td></tr></table></figure>
<h1 id="完成部署："><a href="#完成部署：" class="headerlink" title="完成部署："></a>完成部署：</h1><p>URL访问，可通过docker ip查看应用的虚拟地址。</p>
<h1 id="Docker-Compose编排"><a href="#Docker-Compose编排" class="headerlink" title="Docker Compose编排"></a>Docker Compose编排</h1><p>Docker Compose是用于定义和组装运行多容器分布式应用的工具，<br>它提供一个简单的基于YAML语言的docker－compose.yml配置文件。 通常，我们使用docker定义和运行复杂的应用，<br>使用docker compose，在一个文件里定义多容器应用的启动顺序，起到服务编排的作用。</p>
<h2 id="编写-docker-compose-yaml-文件"><a href="#编写-docker-compose-yaml-文件" class="headerlink" title="编写 docker-compose.yaml 文件"></a>编写 docker-compose.yaml 文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">web:</span>  </div><div class="line"><span class="attr">  build:</span> .  </div><div class="line"><span class="attr">  ports:</span>  </div><div class="line"><span class="bullet">    -</span> <span class="string">"8080:8080"</span>  </div><div class="line"><span class="attr">  links:</span>  </div><div class="line"><span class="attr">    - mongodb:</span>mongodb  </div><div class="line">  </div><div class="line"><span class="attr">mongodb:</span>  </div><div class="line"><span class="attr">  image:</span> daocloud.io/library/mongo:latest  </div><div class="line"><span class="attr">  ports:</span>  </div><div class="line"><span class="bullet">    -</span> <span class="string">"27017:27017"</span></div></pre></td></tr></table></figure>
<p>这里以MongoDB数据库提供服务的demo，在该文件中，我们定于了两个服务：</p>
<pre><code>基于我们应用构建的 docker-demo-java-mongo 镜像，用来提供 Web 服务
基于 DaoCloud 提供的 MongoDB 镜像，提供存储服务
通过 links 为 web 关联 mongo 服务
</code></pre><h2 id="启动-Docker-Compose"><a href="#启动-Docker-Compose" class="headerlink" title="启动 Docker Compose"></a>启动 Docker Compose</h2><pre><code class="yaml">docker-compose up
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[spring Boot Cloud2]]></title>
      <url>https://yangzhiw.github.io/2016/07/27/spring-Boot-Cloud2/</url>
      <content type="html"><![CDATA[<h1 id="Spring-Cloud介绍"><a href="#Spring-Cloud介绍" class="headerlink" title="Spring Cloud介绍"></a>Spring Cloud介绍</h1><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、<br>智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p>
<h1 id="Spring-Cloud与Dubbo对比"><a href="#Spring-Cloud与Dubbo对比" class="headerlink" title="Spring Cloud与Dubbo对比"></a>Spring Cloud与Dubbo对比</h1><p>它们两都具备分布式服务治理相关的功能，都能够提供服务注册、发现、路由、负载均衡等。说到这，Dubbo的功能好像<br>也就这么多了，但是Spring Cloud是提供了一整套企业级分布式云应用的完美解决方案，能够结合Spring Boot，<br>Docker实现快速开发的目的，所以说Dubbo只有Spring Cloud的一部分RPC功能，而且也谈不上谁好谁坏。不过，<br>Dubbo项目现已停止了更新，淘宝内部由hsf替代dubbo，我想这会有更多人倾向Spring Cloud了。<br>从开发角度上说，Dubbo常与Spring、zookeeper结合，而且实现只是通过xml来配置服务地址、名称、端口，<br>代码的侵入性是很小的，相对Spring Cloud，它的实现需要类注解等，多少具有一定侵入性。</p>
<h1 id="Spring-Cloud子项目"><a href="#Spring-Cloud子项目" class="headerlink" title="Spring Cloud子项目"></a>Spring Cloud子项目</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），之前在第一章节也介绍这些，</div><div class="line">比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud CloudFoundry、Spring Cloud AWS、</div><div class="line">Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。</div></pre></td></tr></table></figure>
<h2 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h2><p>Spring Cloud通过Netflix OSS的Eureka来实现服务发现，服务发现的主要目的是为了让每个服务之间可以互相通信。<br>Eureka Server为微服务的注册中心。谈到Spring Cloud Netflix，它是Spring Cloud的子项目之一，主要提供的模块包括：<br>服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。<br>Spring Cloud使用注解的方式提供了Eureka服务端（@EnableEurekaServer）和客户端（@EnableEurekaClient）。</p>
<h2 id="路由网关"><a href="#路由网关" class="headerlink" title="路由网关"></a>路由网关</h2><p>路由网关的主要目的是为了让所有的微服务对外只有一个接口，我们只需访问一个网关地址，即可由网关将所有的请求代理<br>到不同的服务中。Spring Cloud是通过Zuul来实现的，支持自动路由映射到在Eureka Server上注册的服务。<br>Spring Cloud提供了注解@EnableZuulProxy来启用路由代理。</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>Spring Cloud提供了Ribbon和Feign作为客户端的负载均衡。在Spring Cloud下，使用Ribbon直接注入一个RestTemplate<br>对象即可，此RestTemplate已做好负载均衡的配置；而使用Feign只需定义个注解，有@FeignClient注解的接口，<br>然后使用@RequestMapping注解在方法上映射远程的REST服务，此方法也是做好了负载均衡配置。</p>
<h2 id="路断器"><a href="#路断器" class="headerlink" title="路断器"></a>路断器</h2><p>断路器（Circuit Breaker）主要是为了解决当某个方法调用失败的时候，调用后备方法来替代失败的方法，<br>已达到容错／阻止级联错误的功能。Spring Cloud使用@EnableCircuitBreaker来启用断路器支持，<br>使用@HystrixCommand的fallbackMethod来指定后备方法。（@HystrixCommand(fallbackMethod=”fallbackOper”)）<br>Spring Cloud还提供了一个控制台来监控断路器的运行情况，通过@EnableHystrixDashboard注解开启。</p>
<p>Spring Cloud依赖<br><img src="/2016/07/27/spring-Boot-Cloud2/spring_cloud.jpg" alt="spring_cloud" title="spring_cloud"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[spring Boot Cloud 学习1]]></title>
      <url>https://yangzhiw.github.io/2016/07/27/spring-Boot-Cloud/</url>
      <content type="html"><![CDATA[<h1 id="Spring-简介"><a href="#Spring-简介" class="headerlink" title="Spring 简介"></a>Spring 简介</h1><img src="/2016/07/27/spring-Boot-Cloud/Spring.jpg" alt="Spring Project" title="Spring Project">
<p>Spring IO platform:用于系统部署，是可集成的，构建现代化应用的版本平台，具体来说当你使用maven dependency引入spring jar包时它就在工作了。</p>
<p>Spring Boot:旨在简化创建产品级的 Spring 应用和服务，简化了配置文件，使用嵌入式web服务器，含有诸多开箱即用微服务功能，可以和spring cloud联合部署。</p>
<p>Spring Framework:即通常所说的spring 框架，是一个开源的Java/Java EE全功能栈应用程序框架，其它spring项目如spring boot也依赖于此框架。</p>
<p>Spring Cloud：微服务工具包，为开发者提供了在分布式系统的配置管理、服务发现、断路器、智能路由、微代理、控制总线等开发工具包。</p>
<p>Spring XD：是一种运行时环境（服务器软件，非开发框架），组合spring技术，如spring batch、spring boot、spring data，采集大数据并处理。</p>
<p>Spring Data：是一个数据访问及操作的工具包，封装了很多种数据及数据库的访问相关技术，包括：jdbc、Redis、MongoDB、Neo4j等。</p>
<p>Spring Batch：批处理框架，或说是批量任务执行管理器，功能包括任务调度、日志记录/跟踪等。</p>
<p>Spring Security：是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。</p>
<p>Spring Integration：面向企业应用集成（EAI/ESB）的编程框架，支持的通信方式包括HTTP、FTP、TCP/UDP、JMS、RabbitMQ、Email等。</p>
<p>Spring Social：一组工具包，一组连接社交服务API，如Twitter、Facebook、LinkedIn、GitHub等，有几十个。</p>
<p>Spring AMQP：消息队列操作的工具包，主要是封装了RabbitMQ的操作。</p>
<p>Spring HATEOAS：是一个用于支持实现超文本驱动的 REST Web 服务的开发库。</p>
<p>Spring Mobile：是Spring MVC的扩展，用来简化手机上的Web应用开发。</p>
<p>Spring for Android：是Spring框架的一个扩展，其主要目的在乎简化Android本地应用的开发，提供RestTemplate来访问Rest服务。</p>
<p>Spring Web Flow：目标是成为管理Web应用页面流程的最佳方案，将页面跳转流程单独管理，并可配置。</p>
<p>Spring LDAP：是一个用于操作LDAP的Java工具包，基于Spring的JdbcTemplate模式，简化LDAP访问。</p>
<p>Spring Session：session管理的开发工具包，让你可以把session保存到redis等，进行集群化session管理。</p>
<p>Spring Web Services：是基于Spring的Web服务框架，提供SOAP服务开发，允许通过多种方式创建Web服务。</p>
<p>Spring Shell：提供交互式的Shell可让你使用简单的基于Spring的编程模型来开发命令，比如Spring Roo命令。</p>
<p>Spring Roo：是一种Spring开发的辅助工具，使用命令行操作来生成自动化项目，操作非常类似于Rails。</p>
<p>Spring Scala：为Scala语言编程提供的spring框架的封装（新的编程语言，Java平台的Scala于2003年底/2004年初发布）。</p>
<p>Spring BlazeDS Integration：一个开发RIA工具包，可以集成Adobe Flex、BlazeDS、Spring以及Java技术创建RIA。</p>
<p>Spring Loaded：用于实现java程序和web应用的热部署的开源工具。</p>
<p>Spring REST Shell：可以调用Rest服务的命令行工具，敲命令行操作Rest服务。</p>
<a id="more"></a>
<h1 id="Spring-Cloud-项目"><a href="#Spring-Cloud-项目" class="headerlink" title="Spring Cloud 项目"></a>Spring Cloud 项目</h1><p>目前来说spring主要集中于spring boot（用于开发微服务）和spring cloud相关框架的开发，我们从几张图着手理解，然后再具体介绍</p>
<img src="/2016/07/27/spring-Boot-Cloud/spring_cloud.jpg" alt="微服务架构图" title="微服务架构图">
<img src="/2016/07/27/spring-Boot-Cloud/cloud.jpg" alt="微服务架构运行图" title="微服务架构运行图">
<p>spring cloud子项目包括：</p>
<p>Spring Cloud Config：配置管理开发工具包，可以让你把配置放到远程服务器，目前支持本地存储、Git以及Subversion。</p>
<p>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署。</p>
<p>Spring Cloud Netflix：针对多种Netflix组件提供的开发工具包，其中包括Eureka、Hystrix、Zuul、Archaius等。</p>
<p>Netflix Eureka：云端负载均衡，一个基于 REST 的服务，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移。</p>
<p>Netflix Hystrix：容错管理工具，旨在通过控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</p>
<p>Netflix Zuul：边缘服务工具，是提供动态路由，监控，弹性，安全等的边缘服务。</p>
<p>Netflix Archaius：配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</p>
<p>Spring Cloud for Cloud Foundry：通过Oauth2协议绑定服务到CloudFoundry，CloudFoundry是VMware推出的开源PaaS云平台。</p>
<p>Spring Cloud Sleuth：日志收集工具包，封装了Dapper,Zipkin和HTrace操作。</p>
<p>Spring Cloud Data Flow：大数据操作工具，通过命令行方式操作数据流。</p>
<p>Spring Cloud Security：安全工具包，为你的应用程序添加安全控制，主要是指OAuth2。</p>
<p>Spring Cloud Consul：封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p>
<p>Spring Cloud Zookeeper：操作Zookeeper的工具包，用于使用zookeeper方式的服务注册和发现。</p>
<p>Spring Cloud Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。</p>
<p>Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markDown 的使用]]></title>
      <url>https://yangzhiw.github.io/2016/07/22/markDown/</url>
      <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 一级标题</span></div><div class="line"><span class="comment">## 二级标题</span></div><div class="line">依次类推</div></pre></td></tr></table></figure>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，</div><div class="line">有序列表则直接在文字前加 <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> 符号要和文字之间加上一个字符的空格。</div></pre></td></tr></table></figure>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">只需要在文本前加入 &gt; 这种尖括号（大于号）即可</div></pre></td></tr></table></figure>
<h1 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">插入链接与插入图片的语法很像，区别在一个 !号</div></pre></td></tr></table></figure>
<h1 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Markdown 的粗体和斜体也非常简单，用两个 * 包含一段文本就是粗体的语法，</div><div class="line">用一个 * 包含一段文本就是斜体的语法。</div></pre></td></tr></table></figure>
<p><strong>我只粗体</strong>，<em>我是斜体</em>。</p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>表格是我觉得 Markdown 比较累人的地方，例子如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">| Tables        | Are           | Cool  <span class="string">|</span></div><div class="line">| ------------- |:-------------:| -----:|</div><div class="line">| col 3 is      | right-aligned | $1600 |</div><div class="line">| col 2 is      | centered      |   $12 |</div><div class="line">| zebra stripes | are neat      |    $1 |</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>Tables</th>
<th style="text-align:center">Are</th>
<th style="text-align:right">Cool</th>
</tr>
</thead>
<tbody>
<tr>
<td>col 3 is</td>
<td style="text-align:center">right-aligned</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">分割线的语法只需要另起一行，连续输入三个星号 *** 即可。</div></pre></td></tr></table></figure>
<hr>
<h1 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，</div><div class="line">只需要用两个 ` 把中间的代码包裹起来.</div><div class="line"></div><div class="line">如 `System.out.println()`</div></pre></td></tr></table></figure>
<p><code>System.out.println()</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[redis集群搭建]]></title>
      <url>https://yangzhiw.github.io/2016/07/22/redis-cluster/</url>
      <content type="html"><![CDATA[<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">搭建的是一个<span class="number">1</span>主<span class="number">3</span>从的redis+<span class="number">3</span>个哨兵集群的环境，由于是在一台物理机上，所有我们用端口区分。</div><div class="line">物理机IP：<span class="number">192.168</span><span class="number">.0</span><span class="number">.12</span></div><div class="line">主节点master端口：<span class="number">6301</span></div><div class="line">从节点slave1端口：<span class="number">6315</span></div><div class="line">从节点slave2端口：<span class="number">6316</span></div><div class="line">从节点slave3端口：<span class="number">6317</span></div><div class="line">哨兵sentinel1端口：<span class="number">26301</span></div><div class="line">哨兵sentinel2端口：<span class="number">26302</span></div><div class="line">哨兵sentinel3端口：<span class="number">26303</span></div></pre></td></tr></table></figure>
<h1 id="下载redis-amp-amp-复制"><a href="#下载redis-amp-amp-复制" class="headerlink" title="下载redis &amp;&amp; 复制"></a>下载redis &amp;&amp; 复制</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">下载redis后然后解压，</div><div class="line">复制 </div><div class="line">cp redis-benchmark redis-cli redis-server redis-sentinel /usr/bin/ <span class="comment">#这个倒是很有用，这样就不用再执行时加上./了，而且可以在任何地方执行</span></div></pre></td></tr></table></figure>
<h1 id="设置内存分配策略（可选，根据服务器的实际情况进行设置）"><a href="#设置内存分配策略（可选，根据服务器的实际情况进行设置）" class="headerlink" title="设置内存分配策略（可选，根据服务器的实际情况进行设置）"></a>设置内存分配策略（可选，根据服务器的实际情况进行设置）</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/proc/sys/vm/overcommit_memory</div><div class="line">可选值：<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>。</div><div class="line"><span class="number">0</span>， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；</div><div class="line">    否则，内存申请失败，并把错误返回给应用进程。</div><div class="line"><span class="number">1</span>， 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</div><div class="line"><span class="number">2</span>， 表示内核允许分配超过所有物理内存和交换空间总和的内存</div></pre></td></tr></table></figure>
<h1 id="开启redis端口，修改防火墙配置文件"><a href="#开启redis端口，修改防火墙配置文件" class="headerlink" title="开启redis端口，修改防火墙配置文件"></a>开启redis端口，修改防火墙配置文件</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    vi /etc/sysconfig/iptables </div><div class="line">加入端口配置</div><div class="line"><span class="bullet">    -</span>A RH-Firewall<span class="bullet">-1</span>-INPUT -m state --state NEW -m tcp -p tcp --dport <span class="number">6379</span> -j ACCEPT </div><div class="line">重新加载规则</div><div class="line">    service iptables restart</div></pre></td></tr></table></figure>
<h1 id="配置redis-config文件"><a href="#配置redis-config文件" class="headerlink" title="配置redis.config文件"></a>配置redis.config文件</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>、主节点master的配置文件redis_master_6301.config：</div><div class="line"><span class="comment"># Redis configuration file example</span></div><div class="line"><span class="comment">################################## INCLUDES ###################################</span></div><div class="line"><span class="comment"># include /path/to/local.conf</span></div><div class="line"><span class="comment"># include /path/to/other.conf</span></div><div class="line"><span class="comment">################################ GENERAL  #####################################</span></div><div class="line">daemonize <span class="literal">yes</span></div><div class="line">pidfile ./run/redis_slaver1_6315.pid</div><div class="line">port <span class="number">6301</span></div><div class="line">tcp-backlog <span class="number">511</span></div><div class="line"><span class="comment"># bind 192.168.1.100 10.0.0.1</span></div><div class="line"><span class="comment"># bind 127.0.0.1</span></div><div class="line"><span class="comment"># unixsocket /tmp/redis.sock</span></div><div class="line"><span class="comment"># unixsocketperm 700</span></div><div class="line">timeout <span class="number">0</span></div><div class="line">tcp-keepalive <span class="number">0</span></div><div class="line">loglevel notice</div><div class="line">logfile <span class="string">"./run/logs/log_master_6301.log"</span></div><div class="line">databases <span class="number">16</span></div><div class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></div><div class="line">save <span class="string">""</span></div><div class="line"><span class="comment"># save 900 1</span></div><div class="line"><span class="comment"># save 300 10</span></div><div class="line"><span class="comment"># save 60 10000</span></div><div class="line">stop-writes-on-bgsave-error <span class="literal">yes</span></div><div class="line">rdbcompression <span class="literal">yes</span></div><div class="line">rdbchecksum <span class="literal">no</span></div><div class="line">dbfilename dump_6301.rdb</div><div class="line">dir ./run/data</div><div class="line"><span class="comment">################################# REPLICATION #################################</span></div><div class="line">slave-serve-stale-data <span class="literal">yes</span></div><div class="line">slave-read-only <span class="literal">yes</span></div><div class="line">repl-diskless-sync <span class="literal">no</span></div><div class="line">repl-diskless-sync-delay <span class="number">5</span></div><div class="line"><span class="comment"># repl-ping-slave-period 10</span></div><div class="line"><span class="comment"># repl-timeout 60</span></div><div class="line">repl-disable-tcp-nodelay <span class="literal">no</span></div><div class="line"><span class="comment"># repl-backlog-size 1mb</span></div><div class="line"><span class="comment"># repl-backlog-ttl 3600</span></div><div class="line">slave-priority <span class="number">100</span></div><div class="line"><span class="comment"># min-slaves-to-write 3</span></div><div class="line"><span class="comment"># min-slaves-max-lag 10</span></div><div class="line"><span class="comment">################################## SECURITY ###################################</span></div><div class="line"><span class="comment"># rename-command CONFIG ""</span></div><div class="line"><span class="comment">################################### LIMITS ####################################</span></div><div class="line"><span class="comment"># maxclients 10000</span></div><div class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></div><div class="line"><span class="comment"># maxmemory-policy noeviction</span></div><div class="line"><span class="comment"># maxmemory-samples 5</span></div><div class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></div><div class="line">appendonly <span class="literal">no</span></div><div class="line">appendfilename <span class="string">"appendonly_6301.aof"</span></div><div class="line">appendfsync <span class="literal">no</span></div><div class="line"><span class="literal">no</span>-appendfsync-on-rewrite <span class="literal">no</span></div><div class="line">auto-aof-rewrite-percentage <span class="number">100</span></div><div class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</div><div class="line">aof-load-truncated <span class="literal">yes</span></div><div class="line"><span class="comment">################################ LUA SCRIPTING  ###############################</span></div><div class="line">lua-time-limit <span class="number">5000</span></div><div class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></div><div class="line"><span class="comment"># cluster-enabled yes</span></div><div class="line"><span class="comment"># cluster-config-file nodes-6379.conf</span></div><div class="line"><span class="comment"># cluster-node-timeout 15000</span></div><div class="line"><span class="comment"># cluster-slave-validity-factor 10</span></div><div class="line"><span class="comment"># cluster-migration-barrier 1</span></div><div class="line"><span class="comment"># cluster-require-full-coverage yes</span></div><div class="line"><span class="comment">################################## SLOW LOG ###################################</span></div><div class="line">slowlog-log-slower-than <span class="number">10000</span></div><div class="line">slowlog-max-len <span class="number">128</span></div><div class="line"><span class="comment">################################ LATENCY MONITOR ##############################</span></div><div class="line">latency-monitor-threshold <span class="number">0</span></div><div class="line"><span class="comment">############################# EVENT NOTIFICATION ##############################</span></div><div class="line">notify-keyspace-events <span class="string">""</span></div><div class="line"><span class="comment">############################### ADVANCED CONFIG ###############################</span></div><div class="line">hash-max-ziplist-entries <span class="number">512</span></div><div class="line">hash-max-ziplist-value <span class="number">64</span></div><div class="line">list-max-ziplist-entries <span class="number">512</span></div><div class="line">list-max-ziplist-value <span class="number">64</span></div><div class="line">set-max-intset-entries <span class="number">512</span></div><div class="line">zset-max-ziplist-entries <span class="number">128</span></div><div class="line">zset-max-ziplist-value <span class="number">64</span></div><div class="line">hll-sparse-max-bytes <span class="number">3000</span></div><div class="line">activerehashing <span class="literal">yes</span></div><div class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">client-output-buffer-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></div><div class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span></div><div class="line">hz <span class="number">10</span></div><div class="line">aof-rewrite-incremental-fsync <span class="literal">yes</span></div><div class="line"><span class="number">2</span>、从节点slave1的配置文件redis_slave_6315.config：</div><div class="line"><span class="comment"># Redis configuration file example</span></div><div class="line"><span class="comment">################################## INCLUDES ###################################</span></div><div class="line"><span class="comment"># include /path/to/local.conf</span></div><div class="line"><span class="comment"># include /path/to/other.conf</span></div><div class="line"><span class="comment">################################ GENERAL  #####################################</span></div><div class="line">daemonize <span class="literal">yes</span></div><div class="line">pidfile ./run/redis_slaver1_6315.pid</div><div class="line">port <span class="number">6315</span></div><div class="line">tcp-backlog <span class="number">511</span></div><div class="line"><span class="comment"># bind 192.168.1.100 10.0.0.1</span></div><div class="line"><span class="comment"># bind 127.0.0.1</span></div><div class="line"><span class="comment"># unixsocket /tmp/redis.sock</span></div><div class="line"><span class="comment"># unixsocketperm 700</span></div><div class="line">timeout <span class="number">0</span></div><div class="line">tcp-keepalive <span class="number">0</span></div><div class="line">loglevel notice</div><div class="line">logfile <span class="string">"./run/logs/log_slaver1_6315.log"</span></div><div class="line">databases <span class="number">16</span></div><div class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></div><div class="line">save <span class="string">""</span></div><div class="line"><span class="comment"># save 900 1</span></div><div class="line"><span class="comment"># save 300 10</span></div><div class="line"><span class="comment"># save 60 10000</span></div><div class="line">stop-writes-on-bgsave-error <span class="literal">yes</span></div><div class="line">rdbcompression <span class="literal">yes</span></div><div class="line">rdbchecksum <span class="literal">no</span></div><div class="line">dbfilename dump_6315.rdb</div><div class="line">dir ./run/data</div><div class="line"><span class="comment">################################# REPLICATION #################################</span></div><div class="line">slaveof <span class="number">192.168</span><span class="number">.0</span><span class="number">.12</span> <span class="number">6301</span></div><div class="line">slave-serve-stale-data <span class="literal">yes</span></div><div class="line">slave-read-only <span class="literal">yes</span></div><div class="line">repl-diskless-sync <span class="literal">no</span></div><div class="line">repl-diskless-sync-delay <span class="number">5</span></div><div class="line"><span class="comment"># repl-ping-slave-period 10</span></div><div class="line"><span class="comment"># repl-timeout 60</span></div><div class="line">repl-disable-tcp-nodelay <span class="literal">no</span></div><div class="line"><span class="comment"># repl-backlog-size 1mb</span></div><div class="line"><span class="comment"># repl-backlog-ttl 3600</span></div><div class="line">slave-priority <span class="number">80</span></div><div class="line"><span class="comment"># min-slaves-to-write 3</span></div><div class="line"><span class="comment"># min-slaves-max-lag 10</span></div><div class="line"><span class="comment">################################## SECURITY ###################################</span></div><div class="line"><span class="comment"># rename-command CONFIG ""</span></div><div class="line"><span class="comment">################################### LIMITS ####################################</span></div><div class="line"><span class="comment"># maxclients 10000</span></div><div class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></div><div class="line"><span class="comment"># maxmemory-policy noeviction</span></div><div class="line"><span class="comment"># maxmemory-samples 5</span></div><div class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></div><div class="line">appendonly <span class="literal">no</span></div><div class="line">appendfilename <span class="string">"appendonly_6315.aof"</span></div><div class="line">appendfsync <span class="literal">no</span></div><div class="line"><span class="literal">no</span>-appendfsync-on-rewrite <span class="literal">no</span></div><div class="line">auto-aof-rewrite-percentage <span class="number">100</span></div><div class="line">auto-aof-rewrite-min-size <span class="number">64</span>mb</div><div class="line">aof-load-truncated <span class="literal">yes</span></div><div class="line"><span class="comment">################################ LUA SCRIPTING  ###############################</span></div><div class="line">lua-time-limit <span class="number">5000</span></div><div class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></div><div class="line"><span class="comment"># cluster-enabled yes</span></div><div class="line"><span class="comment"># cluster-config-file nodes-6379.conf</span></div><div class="line"><span class="comment"># cluster-node-timeout 15000</span></div><div class="line"><span class="comment"># cluster-slave-validity-factor 10</span></div><div class="line"><span class="comment"># cluster-migration-barrier 1</span></div><div class="line"><span class="comment"># cluster-require-full-coverage yes</span></div><div class="line"><span class="comment">################################## SLOW LOG ###################################</span></div><div class="line">slowlog-log-slower-than <span class="number">10000</span></div><div class="line">slowlog-max-len <span class="number">128</span></div><div class="line"><span class="comment">################################ LATENCY MONITOR ##############################</span></div><div class="line">latency-monitor-threshold <span class="number">0</span></div><div class="line"><span class="comment">############################# EVENT NOTIFICATION ##############################</span></div><div class="line">notify-keyspace-events <span class="string">""</span></div><div class="line"><span class="comment">############################### ADVANCED CONFIG ###############################</span></div><div class="line">hash-max-ziplist-entries <span class="number">512</span></div><div class="line">hash-max-ziplist-value <span class="number">64</span></div><div class="line">list-max-ziplist-entries <span class="number">512</span></div><div class="line">list-max-ziplist-value <span class="number">64</span></div><div class="line">set-max-intset-entries <span class="number">512</span></div><div class="line">zset-max-ziplist-entries <span class="number">128</span></div><div class="line">zset-max-ziplist-value <span class="number">64</span></div><div class="line">hll-sparse-max-bytes <span class="number">3000</span></div><div class="line">activerehashing <span class="literal">yes</span></div><div class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></div><div class="line">client-output-buffer-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></div><div class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span></div><div class="line">hz <span class="number">10</span></div><div class="line">aof-rewrite-incremental-fsync <span class="literal">yes</span></div><div class="line"><span class="number">3</span>、从节点slave2的配置文件redis_slave_6316.config：</div><div class="line">与上面slave1配置文件需要修改的地方</div><div class="line">pidfile ./run/redis_slaver1_6316.pid</div><div class="line">port <span class="number">6316</span></div><div class="line">logfile <span class="string">"./run/logs/log_slaver1_6316.log"</span></div><div class="line">dbfilename dump_6316.rdb</div><div class="line">appendfilename <span class="string">"appendonly_6316.aof"</span></div><div class="line"><span class="number">4</span>、从节点slave3的配置文件redis_slave_6317.config：</div><div class="line">与上面slave1配置文件需要修改的地方</div><div class="line">pidfile ./run/redis_slaver1_6317.pid</div><div class="line">port <span class="number">6317</span></div><div class="line">logfile <span class="string">"./run/logs/log_slaver1_6317.log"</span></div><div class="line">dbfilename dump_6317.rdb</div><div class="line">appendfilename <span class="string">"appendonly_6317.aof"</span></div><div class="line"><span class="number">5</span>、哨兵sentinel1的配置文件sentinel_26301.config:</div><div class="line"><span class="comment"># Example sentinel.conf</span></div><div class="line">port <span class="number">26301</span></div><div class="line"><span class="comment"># sentinel announce-ip 1.2.3.4</span></div><div class="line">dir ./run/tmp</div><div class="line">sentinel monitor master1 <span class="number">192.168</span><span class="number">.0</span><span class="number">.12</span> <span class="number">6301</span> <span class="number">2</span></div><div class="line"><span class="comment"># sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span></div><div class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></div><div class="line">sentinel down-after-milliseconds master1 <span class="number">30000</span></div><div class="line">sentinel parallel-syncs master1 <span class="number">1</span></div><div class="line">sentinel failover-timeout master1 <span class="number">180000</span></div><div class="line"><span class="comment"># sentinel notification-script mymaster /var/redis/notify.sh</span></div><div class="line"><span class="comment"># sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span></div><div class="line"><span class="comment"># sentinel can-failover master1 yes</span></div><div class="line">logfile <span class="string">"/redis-3.0.0/run/logs/sentinellog_m1_26301.log"</span></div><div class="line"><span class="number">6</span>、哨兵sentinel2的配置文件sentinel_26302.config:</div><div class="line"><span class="comment"># Example sentinel.conf</span></div><div class="line">port <span class="number">26302</span></div><div class="line"><span class="comment"># sentinel announce-ip 1.2.3.4</span></div><div class="line">dir ./run/tmp</div><div class="line">sentinel monitor master1 <span class="number">192.168</span><span class="number">.0</span><span class="number">.12</span> <span class="number">6301</span> <span class="number">2</span></div><div class="line"><span class="comment"># sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span></div><div class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></div><div class="line">sentinel down-after-milliseconds master1 <span class="number">30000</span></div><div class="line">sentinel parallel-syncs master1 <span class="number">1</span></div><div class="line">sentinel failover-timeout master1 <span class="number">180000</span></div><div class="line"><span class="comment"># sentinel notification-script mymaster /var/redis/notify.sh</span></div><div class="line"><span class="comment"># sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span></div><div class="line"><span class="comment"># sentinel can-failover master1 yes</span></div><div class="line">logfile <span class="string">"/redis-3.0.0/run/logs/sentinellog_m1_26302.log"</span></div><div class="line"><span class="number">7</span>、哨兵sentinel3的配置文件sentinel_26303.config:</div><div class="line"><span class="comment"># Example sentinel.conf</span></div><div class="line">port <span class="number">26303</span></div><div class="line"><span class="comment"># sentinel announce-ip 1.2.3.4</span></div><div class="line">dir ./run/tmp</div><div class="line">sentinel monitor master1 <span class="number">192.168</span><span class="number">.0</span><span class="number">.12</span> <span class="number">6301</span> <span class="number">2</span></div><div class="line"><span class="comment"># sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span></div><div class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></div><div class="line">sentinel down-after-milliseconds master1 <span class="number">30000</span></div><div class="line">sentinel parallel-syncs master1 <span class="number">1</span></div><div class="line">sentinel failover-timeout master1 <span class="number">180000</span></div><div class="line"><span class="comment"># sentinel notification-script mymaster /var/redis/notify.sh</span></div><div class="line"><span class="comment"># sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span></div><div class="line"><span class="comment"># sentinel can-failover master1 yes</span></div><div class="line">logfile <span class="string">"/redis-3.0.0/run/logs/sentinellog_m1_26303.log"</span></div><div class="line">````    </div><div class="line"></div><div class="line"><span class="comment"># 启动redis和哨兵服务</span></div><div class="line">```yaml</div><div class="line">注意：第一次要先启动redis主服务、从服务，然后才能启动哨兵服务</div><div class="line"><span class="number">1</span>、进入redis安装目录的根目录</div><div class="line"><span class="number">2</span>、启动redis主节点</div><div class="line">[root@localhost redis<span class="bullet">-3.0</span><span class="number">.0</span>]<span class="comment"># redis-server redis_master_6301.config &amp;</span></div><div class="line"><span class="number">3</span>、启动redis从节点</div><div class="line">[root@localhost redis<span class="bullet">-3.0</span><span class="number">.0</span>]<span class="comment"># redis-server redis_slave_6315.config &amp;</span></div><div class="line">[root@localhost redis<span class="bullet">-3.0</span><span class="number">.0</span>]<span class="comment"># redis-server redis_slave_6316.config &amp;</span></div><div class="line">[root@localhost redis<span class="bullet">-3.0</span><span class="number">.0</span>]<span class="comment"># redis-server redis_slave_6317.config &amp;</span></div><div class="line"><span class="number">4</span>、启动哨兵</div><div class="line">[root@localhost redis<span class="bullet">-3.0</span><span class="number">.0</span>]<span class="comment"># redis-sentinel sentinel_26301.config &amp;</span></div><div class="line">[root@localhost redis<span class="bullet">-3.0</span><span class="number">.0</span>]<span class="comment"># redis-sentinel sentinel_26302.config &amp;</span></div><div class="line">[root@localhost redis<span class="bullet">-3.0</span><span class="number">.0</span>]<span class="comment"># redis-sentinel sentinel_26303.config &amp;</span></div><div class="line"></div><div class="line">到目前为止整个redis+sentinel的安装搭建环境就算完成</div><div class="line">`</div></pre></td></tr></table></figure>
<h1 id="常用命名"><a href="#常用命名" class="headerlink" title="常用命名"></a>常用命名</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">进入redis的安装目录</div><div class="line">启动redis-server：</div><div class="line">./redis-server redis_6305.conf &amp;</div><div class="line">启动redis-sentinel </div><div class="line">./redis-sentinel sentinel_6301.config</div><div class="line">./redis-server sentinel_6316.conf --sentinel &amp;</div><div class="line">查看某个端口信息：</div><div class="line">./redis-cli -p <span class="number">6301</span> info</div><div class="line">./redis-cli -p <span class="number">6301</span> info Replication</div><div class="line">./redis-cli -p <span class="number">6301</span> info Sentinel</div><div class="line">查看某个主机上的信息redis信息</div><div class="line">./redis-cli -h <span class="number">10.16</span><span class="number">.41</span><span class="number">.52</span> -p <span class="number">6316</span> info</div><div class="line">./redis-cli -h <span class="number">10.16</span><span class="number">.41</span><span class="number">.52</span> -p <span class="number">6316</span> info Replication</div><div class="line">./redis-cli -h <span class="number">10.16</span><span class="number">.41</span><span class="number">.52</span> -p <span class="number">6316</span> info Sentinel</div><div class="line">关闭本机redis服务</div><div class="line">./redis-cli -p <span class="number">6379</span> shutdown</div><div class="line">关闭远程主机redis服务</div><div class="line">./redis-cli -h <span class="number">192.168</span><span class="number">.9</span><span class="number">.18</span> -p <span class="number">6379</span> shutdown</div><div class="line">客户端连接本机</div><div class="line">./redis-cli -p <span class="number">6301</span></div><div class="line">客户端连接远程机</div><div class="line">./redis-cli -h <span class="number">10.16</span><span class="number">.41</span><span class="number">.53</span> -p <span class="number">6301</span></div><div class="line">切换连接</div><div class="line">ssh app@<span class="number">10.16</span><span class="number">.41</span><span class="number">.52</span></div><div class="line"></div><div class="line">使用命令关闭RDB持久化</div><div class="line">`</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[logback 日志配置]]></title>
      <url>https://yangzhiw.github.io/2016/07/21/logback/</url>
      <content type="html"><![CDATA[<h1 id="写入文件配置"><a href="#写入文件配置" class="headerlink" title="写入文件配置"></a>写入文件配置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;appender name=<span class="string">"FILE"</span> class=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span><span class="string">&gt;</span></div><div class="line">    &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;</div><div class="line">        &lt;fileNamePattern&gt;logFile.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt;</div><div class="line">        &lt;maxHistory&gt;90&lt;/maxHistory&gt;</div><div class="line">    &lt;/rollingPolicy&gt;</div><div class="line">    &lt;encoder&gt;</div><div class="line">        &lt;charset&gt;utf-8&lt;/charset&gt;</div><div class="line">        &lt;Pattern&gt;%d %-5level [%thread] %logger&#123;0&#125;: %msg%n&lt;/Pattern&gt;</div><div class="line">    &lt;/encoder&gt;</div><div class="line">&lt;/appender&gt;</div></pre></td></tr></table></figure>
<h1 id="写入mysql数据库配置"><a href="#写入mysql数据库配置" class="headerlink" title="写入mysql数据库配置"></a>写入mysql数据库配置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;appender name=<span class="string">"DB"</span> class=<span class="string">"ch.qos.logback.classic.db.DBAppender"</span><span class="string">&gt;</span></div><div class="line">     &lt;!--日志异步到数据库 --&gt;</div><div class="line">     &lt;connectionSource class="ch.qos.logback.core.db.DataSourceConnectionSource"&gt;</div><div class="line">         &lt;!--连接池 --&gt;</div><div class="line">         &lt;dataSource class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;</div><div class="line">             &lt;driverClassName&gt;com.mysql.jdbc.Driver&lt;/driverClassName&gt;</div><div class="line">             &lt;url&gt;jdbc:mysql://localhost:3306/DB&lt;/url&gt;</div><div class="line">             &lt;username &gt;root&lt;/username&gt;</div><div class="line">             &lt;password&gt;root&lt;/password&gt;</div><div class="line">         &lt;/dataSource&gt;</div><div class="line">     &lt;/connectionSource&gt;</div><div class="line"> &lt;/appender&gt;</div></pre></td></tr></table></figure>
<h1 id="写入控制台配置"><a href="#写入控制台配置" class="headerlink" title="写入控制台配置"></a>写入控制台配置</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;appender name=<span class="string">"STDOUT"</span> class=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span><span class="string">&gt;</span></div><div class="line">     &lt;!-- 日志输出编码 --&gt;  </div><div class="line">     &lt;Encoding&gt;UTF-8&lt;/Encoding&gt;   </div><div class="line">      &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt;   </div><div class="line">           &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; </div><div class="line">          &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n   </div><div class="line">          &lt;/pattern&gt;   </div><div class="line">      &lt;/layout&gt;   </div><div class="line"> &lt;/appender&gt;</div></pre></td></tr></table></figure>
<h1 id="异步写入"><a href="#异步写入" class="headerlink" title="异步写入"></a>异步写入</h1><pre><code class="yaml">&lt;appender name=<span class="string">"ASYNC"</span> class=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span><span class="string">&gt;
      &lt;queueSize&gt;512&lt;/queueSize&gt;
      &lt;appender-ref ref="FILE"/&gt;
&lt;/appender&gt;</span>
</code></pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://yangzhiw.github.io/2016/07/21/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
