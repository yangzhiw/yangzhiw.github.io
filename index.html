<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>橘子不酸的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录生活点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="橘子不酸的博客">
<meta property="og:url" content="https://yangzhiw.github.io/index.html">
<meta property="og:site_name" content="橘子不酸的博客">
<meta property="og:description" content="记录生活点滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="橘子不酸的博客">
<meta name="twitter:description" content="记录生活点滴">
  
    <link rel="alternate" href="/atom.xml" title="橘子不酸的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">橘子不酸的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一天进步一点</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yangzhiw.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JavaWeb基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/16/JavaWeb基础/" class="article-date">
  <time datetime="2016-08-16T06:57:28.000Z" itemprop="datePublished">2016-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/16/JavaWeb基础/">JavaWeb基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1，Servlet-生命周期、工作原理"><a href="#1，Servlet-生命周期、工作原理" class="headerlink" title="1，Servlet 生命周期、工作原理"></a>1，Servlet 生命周期、工作原理</h1><p><a href="http://www.cnblogs.com/xuekyo/archive/2013/02/24/2924072.html" target="_blank" rel="external">点我跳转</a></p>
<h1 id="2，JSP和Servlet的区别"><a href="#2，JSP和Servlet的区别" class="headerlink" title="2，JSP和Servlet的区别"></a>2，JSP和Servlet的区别</h1><p>jsp经过编译后变成类servlet，<br>jsp由html代码和jsp标签组成，擅长页面显示，servlet擅长流程控制；<br>JSP中嵌入JAVA代码，而Servlet中嵌入HTML代码。</p>
<h1 id="3，JSP的动态include和静态include"><a href="#3，JSP的动态include和静态include" class="headerlink" title="3，JSP的动态include和静态include"></a>3，JSP的动态include和静态include</h1><p>(1)动态include用jsp:include动作实现，如<jsp:include page="abc.jsp" flush="true">，<br>它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。会先解析所要包含的页面，解析后和主页面合并一起显示，即先编译后包含。<br>(2)静态include用include伪码实现，不会检查所含文件的变化，适用于包含静态页面，如&lt;%@ include file=”qq.htm” %&gt;，<br>不会提前解析所要包含的页面，先把要显示的页面包含进来，然后统一编译，即先包含后编译。</jsp:include></p>
<h1 id="4，设计模式的6大原则"><a href="#4，设计模式的6大原则" class="headerlink" title="4，设计模式的6大原则"></a>4，设计模式的6大原则</h1><p>(1)单一职责原则<br>    可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；<br>    提高类的可读性，提高系统的可维护性；<br>    变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p>
<p>(2)里氏替换原则<br>    子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>    子类中可以增加自己特有的方法。<br>    当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。<br>    当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p>
<p>(3)依赖倒置原则<br>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。<br>传递依赖关系的三种关系：<br>    接口传递<br>    构造方法传递<br>    setter方法传递<br>(4)接口隔离原则<br>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，<br>    则会造成接口数量过多，使设计复杂化。所以一定要适度。<br>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，<br>    才能建立最小的依赖关系。<br>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。<br>(5)迪米特法则<br>定义：一个对象应该对其他对象保持最少的了解。<br>(6)开闭原则<br>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<h1 id="4，Hibernate缓存：一级缓存和二级缓存"><a href="#4，Hibernate缓存：一级缓存和二级缓存" class="headerlink" title="4，Hibernate缓存：一级缓存和二级缓存"></a>4，Hibernate缓存：一级缓存和二级缓存</h1><p>Hibernate缓存的分类：<br>(1),Session缓存（又称事物缓存），Hibernate内置的，不能卸载；<br>缓存范围：缓存只能被当前Session对象访问。缓存的生命周期依赖于Session的生命周期，当Session被关闭后，缓存也就结束生命周期。<br>(2)SessionFactory缓存（又称作应用缓存）：使用第三方插件，可插拔.<br>缓存范围：缓存被应用范围内的所有session共享,不同的Session可以共享。这些session有可能是并发访问缓存，因此必须对缓存进行更新。<br>        缓存的生命周期依赖于应用的生命周期，应用结束时，缓存也就结束了生命周期，二级缓存存在于应用程序范围。</p>
<p>一级缓存：<br>(1). save()。当session对象调用save()方法保存一个对象后，该对象会被放入到session的缓存中。<br>(2). get()和load()。当session对象调用get()或load()方法从数据库取出一个对象后，该对象也会被放入到session的缓存中。<br>(3). 使用HQL和QBC等从数据库中查询数据。<br>数据从缓存中清除：<br>(1). evit()将指定的持久化对象从缓存中清除，释放对象所占用的内存资源，指定对象从持久化状态变为脱管状态，从而成为游离对象。<br>(2). clear()将缓存中的所有持久化对象清除，释放其占用的内存资源。<br>其他缓存操作：<br>(1). contains()判断指定的对象是否存在于缓存中。<br>(2). flush()刷新缓存区的内容，使之与数据库数据保持同步。</p>
<p>二级缓存：<br>定义：SessionFactory级别的缓存，可以跨越Session存在，可以被多个Session所共享。<br>实现原理：<br>Hibernate如何将数据库中的数据放入到二级缓存中？注意，你可以把缓存看做是一个Map对象，<br>它的Key用于存储对象OID，Value用于存储POJO。首先，当我们使用Hibernate从数据库中查询出数据，<br>获取检索的数据后，Hibernate将检索出来的对象的OID放入缓存中key 中，然后将具体的POJO放入value中，<br>等待下一次再次向数据查询数据时，Hibernate根据你提供的OID先检索一级缓存，若有且配置了二级缓存，则检索二级缓存，<br>如果还没有则才向数据库发送SQL语句，然后将查询出来的对象放入缓存中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/08/16/JavaWeb基础/" data-id="cirx51q34000094ot8wmpio0g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JaveWeb/">JaveWeb</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络知识复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/12/计算机网络知识复习/" class="article-date">
  <time datetime="2016-08-12T07:57:58.000Z" itemprop="datePublished">2016-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/12/计算机网络知识复习/">计算机网络知识复习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/08/12/计算机网络知识复习/" data-id="cirx51q8j000c94otfg0febdf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring定时任务" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/10/spring定时任务/" class="article-date">
  <time datetime="2016-08-10T02:29:47.000Z" itemprop="datePublished">2016-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/10/spring定时任务/">Spring定时任务</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="获取昨天时间"><a href="#获取昨天时间" class="headerlink" title="获取昨天时间"></a>获取昨天时间</h2><pre><code>Calendar c=Calendar.getInstance();
c.add(Calendar.DAY_OF_MONTH,-1);   //日期月是0-11
c.set(Calendar.HOUR_OF_DAY,0);     
c.set(Calendar.MINUTE,0);
c.set(Calendar.SECOND,0);
c.set(Calendar.MILLISECOND,0);
return c.getTime();
</code></pre><h2 id="在类上加上注解"><a href="#在类上加上注解" class="headerlink" title="在类上加上注解"></a>在类上加上注解</h2><p>@Configuration<br>@EnableScheduling        </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/08/10/spring定时任务/" data-id="cirx51qa3000g94otravlz8ks" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Scheduler/">Scheduler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-获取文件流的编码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/10/获取文件流的编码/" class="article-date">
  <time datetime="2016-08-10T02:29:47.000Z" itemprop="datePublished">2016-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/10/获取文件流的编码/">获取文件流编码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1，获取文件的流"><a href="#1，获取文件的流" class="headerlink" title="1，获取文件的流"></a>1，获取文件的流</h1><pre><code>InportStream importStream = file.getInputStream()；
</code></pre><h1 id="2，把文件流转化为字节流"><a href="#2，把文件流转化为字节流" class="headerlink" title="2，把文件流转化为字节流"></a>2，把文件流转化为字节流</h1><pre><code>//字节数组输出流
ByteArrayOutputStream baos = new ByteArrayOutputStream();
try {
    byte[] buffer = new byte[1024];
    int len;
    while ((len = inputStream.read(buffer)) &gt; -1) {
        baos.write(buffer, 0, len);
    }
    baos.flush();
}catch(IOException e){
    e.printStackTrace();
}
return new ByteArrayInputStream(baos.toByteArray());
</code></pre><h1 id="3，根据字节流的判断文件的编码"><a href="#3，根据字节流的判断文件的编码" class="headerlink" title="3，根据字节流的判断文件的编码"></a>3，根据字节流的判断文件的编码</h1><pre><code>//默认编码
String charset = &quot;GBK&quot;;
byte[] first3Bytes = new byte[3];
//缓存流
BufferedInputStream bis = new BufferedInputStream(inputStream1);
try {
    boolean checked = false;
    //标记
    bis.mark(0);
    //读取文件的前3个字符
    int read = bis.read(first3Bytes, 0, 3);
    if (read == -1) return charset;
    if (first3Bytes[0] == (byte) 0xFF &amp;&amp; first3Bytes[1] == (byte) 0xFE) {
        charset = &quot;UTF-16LE&quot;;
        checked = true;
    } else if (first3Bytes[0] == (byte) 0xFE &amp;&amp; first3Bytes[1] == (byte) 0xFF) {
        charset = &quot;UTF-16BE&quot;;
        checked = true;
    } else if (first3Bytes[0] == (byte) 0xEF &amp;&amp; first3Bytes[1] == (byte) 0xBB &amp;&amp; first3Bytes[2] == (byte) 0xBF) {
        charset = &quot;UTF-8&quot;;
        checked = true;
    }
    bis.reset();
    if (!checked) {

        int loc = 0;
        while ((read = bis.read()) != -1) {
            loc++;
            if (read &gt;= 0xF0) break;
            if (0x80 &lt;= read &amp;&amp; read &lt;= 0xBF) // 单独出现BF以下的，也算是GBK
                break;
            if (0xC0 &lt;= read &amp;&amp; read &lt;= 0xDF) {
                read = bis.read();
                if (0x80 &lt;= read &amp;&amp; read &lt;= 0xBF) // 双字节 (0xC0 - 0xDF) (0x80
                    continue;
                else break;
            } else if (0xE0 &lt;= read &amp;&amp; read &lt;= 0xEF) {// 也有可能出错，但是几率较小
                read = bis.read();
                if (0x80 &lt;= read &amp;&amp; read &lt;= 0xBF) {
                    read = bis.read();
                    if (0x80 &lt;= read &amp;&amp; read &lt;= 0xBF) {
                        charset = &quot;UTF-8&quot;;
                        break;
                    } else break;
                } else break;
            }
        }
    }
} catch (Exception e) {
    e.printStackTrace();
} finally {
    try {
        bis.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/08/10/获取文件流的编码/" data-id="cirx51q98000e94otyn3gvap4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编码/">编码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-基础题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/01/java-基础题/" class="article-date">
  <time datetime="2016-08-01T01:54:12.000Z" itemprop="datePublished">2016-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/01/java-基础题/">java 复习资料</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p>1，面向对象和面向过程的区别<br>2，java的三大特性</p>
<hr>
<pre><code>封装，继承，多态
</code></pre><p>3，OverLoad与Override的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   Override（重写，覆盖） </div><div class="line">方法名、参数、返回值相同。</div><div class="line">子类方法不能缩小父类方法的访问权限。</div><div class="line">子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</div><div class="line">存在于父类和子类之间。</div><div class="line">方法被定义为final不能被重写。</div><div class="line"></div><div class="line">   Overload（重载，过载）</div><div class="line">参数类型、个数、顺序至少有一个不相同。  </div><div class="line">不能重载只有返回值不同的方法名。</div><div class="line">存在于父类和子类、同类中。</div></pre></td></tr></table></figure></p>
<p>4，构造器不能被修饰Override<br>5，访问控制符public,protected,private,以及默认的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">作用域      当前类      同包   子类    其他</div><div class="line">public        √        √       √      √</div><div class="line">protected     √        √       √      ×</div><div class="line">default       √        √       ×      ×</div><div class="line">private       √        ×       ×      ×</div></pre></td></tr></table></figure></p>
<p>6，String和StringBuffer、StringBuilder的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">可变与不可变</div><div class="line">String类中使用字符数组保存字符串，如下就是，因为有“final”修饰符，所以可以知道string对象是不可变的。</div><div class="line">private final char value[];</div><div class="line"></div><div class="line">StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符</div><div class="line">数组保存字符串，如下就是，可知这两种对象都是可变的。</div><div class="line"></div><div class="line">char[] value;</div><div class="line">线程是否安全</div><div class="line">StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</div><div class="line">StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</div></pre></td></tr></table></figure></p>
<p>7，抽象类和接口的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</div><div class="line"></div><div class="line">　　<span class="number">2</span>）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</div><div class="line"></div><div class="line">　　<span class="number">3</span>）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</div><div class="line"></div><div class="line">　　<span class="number">4</span>）一个类只能继承一个抽象类，而一个类却可以实现多个接口。</div></pre></td></tr></table></figure></p>
<p>8，自动装箱与拆箱<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">基本数据类型的自动装箱(autoboxing)、拆箱(unboxing)是自J2SE <span class="number">5.0</span>开始提供的功能。 </div><div class="line">基本数据与对象的区别</div><div class="line">如：int t = <span class="number">1</span>；     t.  后面是没有方法滴。</div><div class="line"></div><div class="line">    Integer t =<span class="number">1</span>； t.  后面就有很多方法可让你调用了。</div><div class="line"></div><div class="line">Integer i = <span class="number">100</span>; // 自动装箱</div><div class="line">相当于编译器自动为您作以下的语法编译：Integer i = Integer.valueOf(<span class="number">100</span>);</div><div class="line">Integer i = <span class="number">10</span>; //装箱 </div><div class="line">int t = i; //拆箱，实际上执行了 int t = i.intValue();    </div><div class="line"></div><div class="line">注意：integer值得默认大小是<span class="bullet">-127</span><span class="bullet">-128</span></div></pre></td></tr></table></figure></p>
<p>7，泛型<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">泛型是Java SE <span class="number">1.5</span>的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数,</div><div class="line">类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，</div><div class="line">将泛型java代码直接转换成普通java字节码。</div><div class="line">     类型擦除的主要过程如下：</div><div class="line">     <span class="number">1.</span>将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。</div><div class="line">     <span class="number">2.</span>移除所有的类型参数。</div></pre></td></tr></table></figure></p>
<p>8,Java中的集合类及其关系图<br>关系图<br><img src="/2016/08/01/java-基础题/java_collection.jpg" alt="微服务架构图" title="微服务架构图"><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">　上述类图中，实线边框的是实现类，比如ArrayList，LinkedList，HashMap等，</div><div class="line">  折线边框的是抽象类，比如AbstractCollection，AbstractList，AbstractMap等，</div><div class="line">  而点线边框的是接口，比如Collection，Iterator，List等。</div><div class="line">  	　		是否有序	是否允许元素重复</div><div class="line">Collection		否		是</div><div class="line">List			是		是</div><div class="line">Set	AbstractSet	否		否</div><div class="line">　	HashSet    	 否		否</div><div class="line">　	TreeSet		是		否</div><div class="line">Map	AbstractMap	否	使用key-value来映射和存储数据，key必须唯一，value可以重复</div><div class="line">　	HashMap</div><div class="line">　	TreeMap		是（用二叉排序树）</div></pre></td></tr></table></figure></p>
<p>9，HashMap的实现原理<br>   见此链接<br>10，HashTable实现原理<br>   见此链接<br>11，HashMap与HashTable的区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">第一，继承不同。</div><div class="line"></div><div class="line">public class Hashtable extends Dictionary implements Map</div><div class="line">public class HashMap  extends AbstractMap implements Map</div><div class="line">第二</div><div class="line"></div><div class="line">Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</div><div class="line"></div><div class="line">第三</div><div class="line"></div><div class="line">Hashtable中，key和value都不允许出现<span class="literal">null</span>值。</div><div class="line"></div><div class="line">在HashMap中，<span class="literal">null</span>可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为<span class="literal">null</span>。当get()方法返回<span class="literal">null</span>值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为<span class="literal">null</span>。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</div><div class="line"></div><div class="line">第四，两个遍历方式的内部实现上不同。</div><div class="line"></div><div class="line">Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</div><div class="line"></div><div class="line">第五</div><div class="line"></div><div class="line">哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</div><div class="line"></div><div class="line">第六</div><div class="line"></div><div class="line">Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是<span class="number">11</span>，增加的方式是 old*<span class="number">2</span>+<span class="number">1</span>。HashMap中hash数组的默认大小是<span class="number">16</span>，而且一定是<span class="number">2</span>的指数。</div></pre></td></tr></table></figure></p>
<p>12，ArrayList和vector区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>）  Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。 </div><div class="line"><span class="number">2</span>） 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加<span class="number">50</span>%的大小，这样,ArrayList就有利于节约内存空间。</div></pre></td></tr></table></figure></p>
<p>13,ArrayList和LinkedList区别及使用场景<br>区别<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ArryList初始化时，elementData数组大小默认为<span class="number">10</span>；</div><div class="line">每次add（）时，先调用ensureCapacity（）保证数组不会溢出，如果此时已满，会扩展为数组length的<span class="number">1.5</span>倍+<span class="number">1</span>，</div><div class="line">然后用array.copy的方法，将原数组拷贝到新的数组中；线程不安全。</div><div class="line"></div><div class="line">LinkedList是基于双链表实现的：</div><div class="line">使用header的优点是：在任何一个条目（包括第一个和最后一个）都有一个前置条目和一个后置条目，</div><div class="line">因此在LinkedList对象的开始或者末尾进行插入操作没有特殊的地方；</div></pre></td></tr></table></figure></p>
<p>使用场景<br>   （1）查询操作多，ArrayList对象要远优于LinkedList对象；</p>
<p>   （2）修改和删除操作多，LinkedList对象要远优于ArrayList对象；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yangzhiw.github.io/2016/08/01/java-基础题/" data-id="cirx51q80000894otaiyk5en8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JaveWeb/">JaveWeb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheduler/">Scheduler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-AOP/">spring AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编码/">编码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/JaveWeb/" style="font-size: 10px;">JaveWeb</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Scheduler/" style="font-size: 10px;">Scheduler</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-Boot/" style="font-size: 20px;">Spring Boot</a> <a href="/tags/Spring-Cloud/" style="font-size: 20px;">Spring Cloud</a> <a href="/tags/spring-AOP/" style="font-size: 10px;">spring AOP</a> <a href="/tags/编码/" style="font-size: 10px;">编码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/16/JavaWeb基础/">JavaWeb基础</a>
          </li>
        
          <li>
            <a href="/2016/08/12/计算机网络知识复习/">计算机网络知识复习</a>
          </li>
        
          <li>
            <a href="/2016/08/10/spring定时任务/">Spring定时任务</a>
          </li>
        
          <li>
            <a href="/2016/08/10/获取文件流的编码/">获取文件流编码</a>
          </li>
        
          <li>
            <a href="/2016/08/01/java-基础题/">java 复习资料</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>